\documentclass[../Thesis.tex]{subfiles}

\begin{document}

\chapter{Formal Model}
\label{chapter:FormalModel}
This chapter presents a formal model used to study the semantics of the \texttt{diff} and \texttt{diff3} algorithms.
The model has been developed in the Agda proof assistant
\cite{Bove09, NorellPhd, Norell08} and used to mechanically 
verify several properties of the algorithms.
In the presentation minor details such as implicit arguments and \texttt{Set} levels will be omitted to improve readability. 	

\section{Introduction}

	\subsection{Motivation}
	In practice the semantics of merging algorithms employed in version control 
	systems is not formalized, but it is usually understood empirically,
	leading to severe misconceptions \cite{PierceDiff3}.
	
	For instance it is often hard to predict the outcome of complex merging 	
	operations.
	It is unclear whether a conflict detected is indeed due to two irreconcilable 
	edits or the consequence of a bug. 
	Furthermore, even when merges are successful, they might produce 
	unexpected	results, for instance duplicating lines or changing their order.
	When software artifacts are under revision control, they might produce 
	invalid programs, or, even worse, they could silently alter 
	their semantics \cite{Mens02}.

	A formal model would identify the specifications of these algorithms,
	thus unambiguously clearing all these matters.
	For example the necessary condition discussed in section 
	\ref{par:ConflictNec} sorts out the first issue and the safety
	properties presented in \ref{subsec:Safety} address the second.

	\subsection{Characteristics}
	The basic characteristics of the merger devised in this thesis
	are listed in this section. They should help the reader to grasp
	its essential traits, to categorize it and quickly compare it to similar tools.
	
	\paragraph{Structured Data}
	 Some tools, such as 3DM by Lindholm, target specific data formats, such as 
	 HTML and XML \cite{Lind04, Lind05}, or are specifically designed for 
	 software  artifacts \cite{Apel11, Westfechtel91}, like those
	 survey by Mens \cite{Mens02}.
	 There are also a number of file systems synchronizers like Unison
	 \cite{Pierce98, UnisonSpec} and	that by Ramsey et al.\ \cite{Ramsey01}.	 
	 The algorithms developed in this thesis target structured data more 
	 generally, just like those of Chawathe et al. \cite{Chawathe96, 
	 Chawathe97}.
	 Specifically it is intended for algebraic data types, represented 
	 consequently as typed, ordered rose-trees.
	 
	\paragraph{Syntactic Merging}	
	\emph{Textual} mergers work directly on files, without taking into account 
	the possible structure of their content. The most widespread tool in this 
	category is GNU diff3.
	They are by design fairly general, but sometimes imprecise, because of the 
	fixed granularity of the diffs produced \cite{Mens02}.
	Conversely \emph{syntactic merging} is more precise, because it 
	works on parse trees \cite{Mens02}, obtained parsing the input files
	accordingly to their formats.
	The merger discussed here performs syntactic merging, applying
	a variant of the three-way merge algorithm to the nodes of the parse tree.
	Correspondingly it raises a conflict if the merged
	object is not well-structured, which in this setting corresponds to 
	an ill-typed term.
	
	\paragraph{Global Alignment}
	Any synchronizer has to find corresponding parts in each replica, i.e.\
	fragments that are somehow related and should be synchronized 
	\cite{Pierce07}.
	This process, called \emph{alignment}, is either \emph{global} or 
	\emph{local}. In the first case the whole replicas are inspected, usually
	employing a global heuristic to find a good alignment. 
	Conversely in the second case, simple rules are applied locally in specific 
	points of the replicas. For instance Harmony aligns trees whose
	children have the same names \cite{Pierce07}.
	This works deploys a \emph{global} heuristic, analogous to that
	of \texttt{diff3}, which computes one of the best alignment minimizing an
	appropriate cost model.	
	
	\paragraph{State-based and three-way}
	The merger discussed in this work is \emph{state-based}, i.e.\ 
	it relies only on the current states of the replicas to be merged, instead
	of the list of operations that generated them \cite{PierceDiff3}.
	Furthermore it is \emph{three-way}, so it takes as input two different 
	versions of the same object together with a previous common one, 
	from which they both derived \cite{PierceDiff3}.	
	The main advantage of a state-based approach is that applications
	are loosely coupled with the synchronizer, which can be used
	off the shelf \cite{PierceDiff3}.
	On the other hand, \emph{change-based} techniques, such as 
	that employed by Ramsey et al.\ \cite{Ramsey01}, 
	require applications	to be data-replication aware
	and to track the operations performed in form of logs.
	The main benefit of this approach is that the presence of \emph{explicit}
	operations logs prevents certain kinds of conflict, resulting in a
	greater number of successful merges.
		
	\paragraph{Persistent}
	Similarly to Harmony \cite{Pierce07}, the merger proposed in 
	this thesis is \emph{persistent}, i.e.\ when merging two replicas 
	it will not back out the incompatible changes it may detect, 
	but it will instead report a conflict to the user.
	Foster et al.\ remark that persistence precludes 
	\emph{convergence} \cite{Pierce07}, the guarantee
	that the merger will always synchronize the two replicas to a same version, 
	at the cost of backing out conflicting edits as needed.
	
	\subsection{Reasoning by Specification}
	\label{subsec:spec}
	In Agda it is inconvenient and cumbersome to reason about algorithms directly.
	Firstly proofs are non-reusable, because they are completely tailored 
	on specific algorithms.
	Secondly, goals are reduced only following the exact same steps
	of the algorithm,	which leads to overly long and repetitive proofs. 
	This style of reasoning is tiresome, inopportune and obfuscates proofs.

	It is preferable, instead, to reason in terms of \emph{specifications}, which
	can be expressed idiomatically in a data type indexed by inputs
	and outputs of the algorithm. 
	The advantages of this approach are threefold.
	Firstly it requires to define the specifications clearly and precisely.
	Furthermore it fosters 	reasoning in terms of high-level properties, 
	abstracting from implementation specific details.
	Secondly it encourages proof reuse, because theorems will be valid for
	all the algorithms that satisfy the same specifications.
	Thirdly it allows much easier and intuitive proofs by induction, since it 
	becomes possible to pattern match directly on the specification data type.
	
	This is a general technique that can be employed in similar 
	situations, furthermore it is lightweight because it only requires 
	to show that the algorithm satisfies the specifications set.
	This approach, sometimes called the graph of the function 
	\cite{FunctionDomains} has been widely employed in this project with 
	positive results, for example in \ref{subsec:Diff}, \ref{subsec:AlgoDiff}.
	
	\subsection{Naming Conventions}
	The following naming conventions will be consistently used in the rest of  
	the thesis.
	\begin{itemize}
		\item \texttt{a b c :\ Set}
		\item \texttt{as bs cs :\ List Set}
		\item \texttt{α β γ :\ F as a} are called \emph{nodes}
		\item \texttt{xs ys zs :\ DList as}
		\item \texttt{u v w z :\ Val as bs} are called \emph{values}
		\item \texttt{f g h :\ u \textasciitilde> v} are called  \emph{edits},
		\emph{transformations} or \emph{operations}.
	\end{itemize}

\section{Basics}
This section defines the core concepts of the model.
Section \ref{subsec:DTree} introduces the generic, type-safe representation of data types employed in the model; sections \ref{subsec:EditScript} and
\ref{subsec:Diff} extend the work of Lempsink et al.\ on type-safe diff and
edit scripts \cite{Lemp09}. 
Then section \ref{subsec:Merge} explains the global
alignment strategy deployed and formalizes the merging rules 
for edits. Lastly sections \ref{subsec:Diff3} and \ref{subsec:Merged3} further elaborate on merging by extending it to edit scripts.

	\subsection{Heterogeneous Rose Trees}
	\label{subsec:DTree}
		Since the ultimate purpose of this work is to detect changes in 
		data types, a generic suitable representation is needed. 
		Algebraic data types are isomorphic to ordered heterogeneous typed 
		trees, in which labeled nodes correspond to constructors and
		their children to their fields. 
		
		The mutually recursive data types \texttt{DTree} and \texttt{DList} are
		defined as follows: 
					
\begin{minted}{agda}
  data DTree : Set -> Set where
    Node : F as a -> DList as -> DTree a

  data DList : List Set -> Set where
    [] : DList []
   _∷_ : DTree x -> DList xs -> DList (x ∷ xs)
\end{minted}
	
		A tree of type \texttt{DTree a} represents a value of type \texttt{a}; 
		a list of trees of type \texttt{DList as} represents a list of 
		\texttt{DTree} whose types are determined by \texttt{as}.
		The term \texttt{F as a} represents a constructor of an algebraic data
		type of type \texttt{a} that takes arguments of types \texttt{as} 

		The \texttt{DTree} encoding is well-typed by construction, because 
		in the signature of \texttt{Node}, the same index \texttt{as}
		is shared by \texttt{F as a} and \texttt{DList as}, therefore  
		representing a well-typed application of a constructor to arguments of 
		the correct type.

	\paragraph{Example}
	Consider a data type that represents arithmetic expressions:
\begin{minted}{agda}
data Expr : Set where
  One : Expr
  Add : Expr -> Expr -> Expr
\end{minted}

	Its constructors are represented by the following data type\footnote{As shown in this example Agda allows to overload constructors. It should
	always be clear from the context to which type they refer.}:
\begin{minted}{agda}
data F : List Set -> Set -> Set where
  One : F [] Expr
  Add : F (Expr ∷ Expr ∷ []) Expr
\end{minted}

	The value \texttt{Add One One} is encoded as
	the following tree:
\begin{minted}{agda}
two :: DTree Expr
two = Node Add (Node One [] ∷ Node One [] ∷ [])
\end{minted}

		For simplicity the data type \texttt{F} is kept abstract using a postulate. 
		Furthermore some basic functions to manipulate it are assumed
		\footnote{The function \texttt{=?=} actually requires heterogeneous
		equality, because the two nodes have different types.}.
				
\begin{minted}{agda}
  postulate F : List Set -> Set -> Set 
  postulate _=?=_ : (α : F as a) (β : F bs b) -> Dec (α ≡ β)
  postulate eq? : F as a  -> F bs b -> Dec (a ≡ b)
\end{minted}

	Note that it is possible to explicitly implement these features in a 
	type-safe family for closed families of mutually recursive data types, 
	as Lempsink et al. did \cite{Lemp09}, specifically using modules 
	parametrized by the family of mutually recursive types. 
	I have decided to avoid this encoding to simplify the model.
		
	\paragraph{Utility Functions}
	\label{par:UtilityFun}
	The signature of two \texttt{DList} utility functions are reported here.
	Their implementation is straightforward and omitted.

\begin{minted}{agda}
_+++_ : DList as -> DList bs -> DList (as ++ bs)
dsplit : ∀ {{as bs}} -> DList (as ++ bs) -> DList as × DList bs
\end{minted}
	
	The first function appends two \texttt{DList}, while the second function,
	inverse of the first, splits a list in two parts.
	In the latter function the lists \texttt{as} and \texttt{bs} are passed
	as \emph{instance} arguments, a special type of implicit arguments 
	that is automatically resolved at call-sites \cite{Devriese11}.
		 
	\subsection{Edit Script}
	\label{subsec:EditScript}
	An edit script is a list of edit operations that transform the source object 
	into the target object.

	Single operations are defined over values, which denote the
	presence or absence of a node. 
			
\begin{minted}{agda}
data Val : List Set -> List Set -> Set where
  ⊥ : Val [] []
  ⟨_⟩ : F as a -> Val as [ a ] 
\end{minted}
	The data type is indexed by two lists that respectively contain
	 the types of the fields	of a node and its resulting type.
	 Empty values do not store a node, hence their lists are both empty.
	 These two indexes are needed to stack edits in a type safe
	 manner.
	
	The edit operations considered in the model are a superset of the edit
	operations normally found in GNU \texttt{diff} edit scripts and in 
	that of Lempsink \cite{Lemp09}.
	An edit operation is indexed over two values, which are respectively
	the \emph{source} and the \emph{target} of the transformation.
	
\begin{minted}{agda}
data _~>_ : Val as bs -> Val cs ds -> Set where
  Nop : ⊥ ~> ⊥
  Del : (α : F as a) -> ⟨ α ⟩ ~> ⊥
  Ins : (α : F as a) -> ⊥ ~> ⟨ α ⟩
  Upd : (α : F as a) (β : F bs a) -> ⟨ α ⟩ ~> ⟨ β ⟩
\end{minted}
	
	The \texttt{Nop} edit is a no-operation that does nothing
	at all; the \texttt{Del α} and \texttt{Ins α} edits represent 
	respectively the deletion and the insertion of the node \texttt{α}, and as 
	such the target of the former and the source of latter are \texttt{⊥}.
	Lastly \texttt{Upd α β} denotes the update of the node \texttt{α}
	to \texttt{β}, which concretely represents changing a constructor. 
	Note that when \texttt{α ≅ β} the update is simply a copy.

	An edit script collects a finite number of edit operations, 
	while preserving type-safety.
\begin{minted}{agda}
data ES : List Set -> List Set -> Set where
  [] : ES [] []
  _::_ : {v : Val as bs} {w : Val cs ds} -> 
          v ~> w -> ES (as ++ xs) (cs ++ ys) -> ES (bs ++ xs) (ds ++ ys)
\end{minted}

	\paragraph{Type Safety}
	In the second constructor the prefixes \texttt{as} and \texttt{cs} match
	the input types of \texttt{v} and \texttt{w}.
	In the resulting type \texttt{as} and \texttt{cs} are replaced with
	\texttt{bs} and \texttt{cs}, which are the output types of 
	\texttt{v} and \texttt{w}.
	
	\paragraph{Source and Target object}
	\label{par:SourceTargetObj}
	An edit script of type \texttt{ES xs ys} contains the edits
	that transform a \texttt{DList xs}, called \emph{source}, 
	in a \texttt{DList ys}, called \emph{target}. 
	The \emph{source function} \texttt{⟪ e ⟫} computes
	the source of the source of the edit script \texttt{e}:
		
\begin{minted}{agda}
⟪_⟫ : ES as bs -> DList as
⟪ [] ⟫ = []
⟪ Nop ∷ e ⟫ = ⟪ e ⟫
⟪ Del α ∷ e ⟫ with dsplit ⟪ e ⟫
... | ds₁ , ds₂ = Node α ds₁ ∷ ds₂
⟪ Ins α ∷ e ⟫ = ⟪ e ⟫
⟪ Upd α β ∷ e ⟫ with dsplit ⟪ e ⟫
... | ds₁ , ds₂ = Node α ds₁ ∷ ds₂
\end{minted}

Analogously the \emph{target function} \texttt{⟦ e ⟧} 
computes its target object:

\begin{minted}{agda}
⟦_⟧ : ES as bs -> DList bs
⟦ [] ⟧ = []
⟦ Nop ∷ e ⟧ = ⟦ e ⟧
⟦ Del α ∷ e ⟧ = ⟦ e ⟧
⟦ Upd α β ∷ e ⟧ with dsplit ⟦ e ⟧
... | ds₁ , ds₂ = Node β ds₁ ∷ ds₂
⟦ Ins α ∷ e ⟧ with dsplit ⟦ e ⟧
... | ds₁ , ds₂ = Node α ds₁ ∷ ds₂
\end{minted}

Edit scripts manipulate lists of trees rather than single trees, because some operations inherently produce lists of trees \cite{Lemp09}.
For instance \texttt{Del α} in \texttt{⟦\_⟧} deletes the node \texttt{α} 
leaving the list of its children, and similarly for \texttt{Ins α} in \texttt{⟪\_⟫}.

	\subsection{Diff}	
	\label{subsec:Diff}
	The data type \texttt{Diff xs ys e} is indexed over the \emph{source}  list 
	\texttt{xs} and the \emph{target} list \texttt{ys} and the edit script 
	\texttt{e},  and represents the proof that \texttt{e} transforms \texttt{xs} 	in \texttt{ys}.
	The two lists are used as stacks, from which arguments for 
	edit operations are popped and results are pushed.

\begin{minted}{agda}
data Diff : DList as -> DList bs -> ES as bs -> Set₁ where
 End : Diff [] [] []
 Nop : Diff xs ys e -> Diff xs ys (Nop ∷ e)
 Del : (α : F as a) -> Diff (xs₁ +++ xs₂) ys e -> Diff (Node α xs₁ ∷ xs₂) ys (Del α ∷ e)
 Ins : (α : F as a) -> Diff xs (ys₁ +++ ys₂) e -> Diff xs (Node α ys₁ ∷ ys₂) (Ins α ∷ e)
 Upd : (α : F as a) (β : F bs a) -> Diff (xs₁ +++ xs₂) (ys₁ +++ ys₂) e 
       -> Diff (Node α xs₁ ∷ xs₂) (Node β ys₁ ∷ ys₂) (Upd α β ∷ e)
\end{minted}	

	The base rule \texttt{End} states that the empty edit script 
	transforms the empty source list in the empty target list.
	Every other rule, one for each edit, appends a different edit 
	to the edit script 	index and affect the input and target lists 
	accordingly to their 	semantics: 
	\texttt{Del} consumes the source list, \texttt{Ins} consumes the target list, 
	\texttt{Upd} consumes both and \texttt{Nop} consumes none.	

	The following result links edit scripts, diff and source and target object.
	
\begin{minted}{agda}	
mkDiff : (e : ES as bs) -> Diff ⟪ e ⟫ ⟦ e ⟧ e
\end{minted}

	An edit script can be turned into a \texttt{Diff} object in which the
	source and target objects are given respectively by \texttt{⟪ e ⟫} and 
	\texttt{⟦ e ⟧}.
	The function is defined by induction on the edit script.
	
	Conversely the following theorems show the correspondence
	between sources and targets of \texttt{Diff} and \texttt{e}. 

\begin{minted}{agda}
mkDiff⟪_⟫ : Diff xs ys e -> xs ≡ ⟪ e ⟫
mkDiff⟦_⟧ : Diff xs ys e -> ys ≡ ⟦ e ⟧
\end{minted}

	The proofs are by induction on \texttt{Diff xs ys e}.
	
	It is now evident that \texttt{Diff xs ys e} and \texttt{Diff  ⟪ e ⟫ ⟦ e ⟧ e} 
	are equivalent	representations, hence in other proofs it is possible to freely 
	choose the most convenient. 
	For instance pattern matching directly on terms whose type include 
	the expressions \texttt{⟪ e ⟫} or
	\texttt{⟦ e ⟧}, is usually not possible, because the function application
	in the indices prevents unification. 
	It is more convenient to introduce the term
	\texttt{Diff xs ys e} and set \texttt{xs} and \texttt{ys} in the terms, 
	enabling case analysis. Lastly, using 
	these equalities and exploiting rewriting techniques, it is possible
	to restore the original and more involved statement.
	See section \ref{subsec:Embedding} for an example.
	
	\subsection{Merge}	
	\label{subsec:Merge}
	The technique devised to merge edits is to apply the three-way
	merge strategy on values. 
	Informally the three-way merge algorithm compares correspondent sections 
	of two files and of their common ancestor.
	When the sections of the two files disagree, the version of the ancestor
	is taken into account. If all of them are different a conflict is detected,
	otherwise the version that changed from the common ancestor is chosen.
	
	To put this strategy on a formal footing a number of auxiliary definitions 
	are needed. For example it is essential to define precisely the meaning 
	of \emph{corresponding sections}. 
	
	\paragraph{Aligned}
	Two edit operations are \emph{aligned} if they share the same source value.	
	Two aligned edits contain at most three distinct values: 
	one common source and two, 	possibly different, targets, which 
	are treated as corresponding sections.
	Since the type of an edit uniquely determines its value, enforcing
	the alignment of two edits is as simple as setting the same source value 
	in their types: no additional data type is required.
	
	Merging is an operation defined over two aligned edits:
	either it fails raising a conflict, or succeeds producing an edit that 
	comprises both. 
	The following data type represents a successful merge.

\begin{minted}{agda}	
data _⊔_↧_ : v ~> a -> v ~> b -> v ~> c -> Set where
  Id₁ : (f : v ~> v) (g : v ~> w) -> f ⊔ g ↧ g
  Id₂ : (f : v ~> w) (g : v ~> v) -> f ⊔ g ↧ f
  Idem : (f : v ~> w) -> f ⊔ f ↧ f
\end{minted}

	A value of type \texttt{f ⊔ g ↧ h} is the proof that merging \texttt{f} with
	\texttt{g} succeeds producing the edit \texttt{h}.
	Each constructor represents a distinct axiom that explains why
	the merge is possible and determines the merged edit.
	The rules \texttt{Id₁} and \texttt{Id₂} apply when 
	respectively the first and the second transformation is an identity edit.
	Accordingly to the three-way merge algorithm, when the source node
	is unchanged in one edit, the other edit is chosen.
	The fact that merging is an \emph{idempotent} operation motivates the 
	third rule \texttt{Idem}.
	It accounts especially for false-positive conflicts and applies 
	when the same edit is performed independently.
	
	Note that this definition is particularly effective because it is 
	minimal and concise, for instance it does not mention specific
	edits, yet complete, since it can represent all the true specific merges.

	Conflicts are represented by the following data type, indexed by 
	a source value and two target values.

\begin{minted}{agda}	
data Conflict : (u : Val as bs) (v : Val cs ds) (w : Val es fs) -> Set where
  UpdUpd : (α : F as a) (β : F bs a) (γ : F cs a) -> Conflict ⟨ α ⟩ ⟨ β ⟩ ⟨ γ ⟩
  DelUpd : (α : F as a) (β : F bs a) -> Conflict ⟨ α ⟩ ⊥ ⟨ β ⟩
  UpdDel : (α : F as a) (β : F bs a) -> Conflict ⟨ α ⟩ ⟨ β ⟩ ⊥ 
  InsIns : (α : F as a) (β : F bs b) -> Conflict ⊥ ⟨ α ⟩ ⟨ β ⟩
\end{minted}
	
	Conflicts given by \texttt{InsIns} and \texttt{UpdUpd}	 correspond to 
	conflicting insertions and updates which resemble to some extent the
	conflicts in the original \texttt{diff₃}. Those given by \texttt{UpdDel} and 
	\texttt{DelUpd} are entirely new and stem from the fact that these two
	edits are in general non mergeable.
	
	Two incompatible edits give rise to a conflict as described by the
	next data type:
	
\begin{minted}{agda}
data _⊔_↥_ : (v ~> w) -> (v ~> z) -> Conflict v w z -> Set where
  InsIns : (f : ⊥ ~> ⟨ α ⟩) (g : ⊥ ~> ⟨ β ⟩) (α≠β : ¬ (α ⋍ β)) 
        -> f ⊔ g ↥ InsIns α β
  UpdUpd : (f : ⟨ α ⟩ ~> ⟨ β ⟩) (g : ⟨ α ⟩ ~> ⟨ γ ⟩)  (α≠β : ¬ (α ⋍ β)) 
             (α≠γ : ¬ (α ⋍ γ)) (β≠γ : ¬ (β ⋍ γ)) 
        -> f ⊔ g ↥ UpdUpd α β γ
  UpdDel : (f : ⟨ α ⟩ ~> ⟨ β ⟩) (g : ⟨ α ⟩ ~> ⊥) (α≠β : ¬ (α ⋍ β)) 
        -> f ⊔ g ↥ UpdDel α β
  DelUpd : (f : ⟨ α ⟩ ~> ⊥) (g : ⟨ α ⟩ ~> ⟨ β ⟩) (α≠β : ¬ (α ⋍ β)) 
        -> f ⊔ g ↥ DelUpd α β
\end{minted}
	
	Each constructor includes additionally inequality proofs, essential 
	to make \texttt{\_⊔\_↧\_} and \texttt{\_⊔\_↥\_} exclusive.
	Inequality is logically encoded in Agda as negated equality: the type 
	\texttt{¬ P} is a synonym for \texttt{P -> ⊥}, where \texttt{⊥} is
	the constructorless data type, which corresponds to falsity 
	under the Curry-Howard isomorphism \cite{PropositionAsTypes}.
	Section \ref{par:MutualExclusion} include
	theorems that explicitly rely on them.

	The binary operator \texttt{⊔} merges two aligned edits.
	For every pair of edits \texttt{f} and \texttt{g}, 
	it either finds a suitable edit \texttt{h} and provide
	a proof that \texttt{f ⊔ g ↧ h}, or detects a conflict \texttt{c}, 
	with a proof that \texttt{f ⊔ g ↥ c}.

\begin{minted}{agda}
_⊔_ : (f : u ~> v) (g : u ~> w) -> (∃ λ c -> f ⊔ g ↥ c) ⊎ (∃ λ h -> f ⊔ g ↧ h)
\end{minted}

	Table \ref{table:merge} schematically outlines its implementation.

	\begin{table}[h]
	\centering
	\begin{tabular}{| c | c | c |}
	\hline
	\texttt{f : u \textasciitilde> v} & \texttt{g : u \textasciitilde> w} &  \texttt{f ⊔ g} 
	\\ \hline
	\texttt{Nop} & \texttt{g} & \textcolor{Green}{\texttt{Id₁ Nop g}} 
	\\ \hline
	\texttt{Upd α α} & \texttt{g} & \textcolor{Green}{\texttt{Id₁ (Upd α α) g}} 
	\\ \hline
	\texttt{f} & \texttt{Nop} & \textcolor{Green}{\texttt{Id₂ f Nop}} 
	\\ \hline
	\texttt{f} & \texttt{Upd α α} & \textcolor{Green}{\texttt{Id₂ f (Upd α α)}} 
	\\ \hline
	\texttt{Del α} & \texttt{Del α} & \textcolor{Green}{\texttt{Idem (Del α)}}
	\\ \hline
	\texttt{Del α} & \texttt{Upd α β} & \textcolor{Red}{\texttt{DelUpd (Del α) (Upd α β) α≠β}}
	\\ \hline
	\texttt{Upd α β} & \texttt{Del α} & \textcolor{Red}{\texttt{UpdDel (Upd α β) (Del α) α≠β}}
	\\ \hline
	\texttt{Ins α} & \texttt{Ins α} & \textcolor{Green}{\texttt{Idem (Ins α)}} 
	\\	\hline
	\texttt{Ins α} & \texttt{Ins β} & \textcolor{Red}{\texttt{InsIns (Ins α) (Ins β) α≠β}}
	\\	\hline
	\texttt{Upd α β} & \texttt{Upd α β} & \textcolor{Green}{\texttt{Idem (Upd α β)}}
	\\	\hline
	\texttt{Upd α β} & \texttt{Upd α γ} & \textcolor{Red}{\texttt{UpdUpd (Upd α β) (Upd α γ) α≠β α≠γ β≠γ)}}
	\\ \hline
	\end{tabular}
	\caption{Implementation of \texttt{⊔}. \textcolor{Red}{\texttt{f ⊔ g ↥ c}}, \textcolor{Green}{\texttt{f ⊔ g ↧ h}}.}
	\label{table:merge}
	\end{table}		

	\subsection{Diff$_3$}
	\label{subsec:Diff3}
	The definition of alignment can be naturally extended to edit scripts.
	Two edit scripts are \emph{aligned} if all their edits are pairwise aligned.	
	The type \texttt{e₁ ⋎ e₂} denotes total alignment:
	
\begin{minted}{agda}
data _⋎_ : ES as bs -> ES as cs -> Set where
  nil : [] ⋎ []
  cons : (f : u ~> v) (g : u ~> w) -> e₁ ⋎ e₂ -> f ∷ e₁ ⋎ g ∷ e₂ 
\end{minted}

	Merging can also be lifted to edit scripts in a similar fashion: it
	consists in merging each of their aligned edits pointwise.
	
	However, since single merges can fail, the merged edit
	script may contain conflicts, hence a variant of \texttt{ES} 
	is introduced:
	\begin{minted}{agda}
data ES₃ : List Set -> Set where
  [] : ES₃ []
  _∷_ : {u : Val as bs} -> u ~> v -> ES₃ (as ++ xs) -> ES₃ (bs ++ xs)
  _∷ᶜ_ : {u : Val as bs} -> (c : Conflict u v w) -> ES₃ (as ++ xs) -> ES₃ (bs ++ xs)
	\end{minted}
	
	The data type \texttt{ES₃}, contrary to \texttt{ES}, is index over only 
	the input type list, and preserves type-safety only with respect to it.
	It also contains one additional constructor to include conflicts.
	
	The rules that specify how aligned edit scripts are merged to produce
	an \texttt{ES₃}, form the following data type:
	
\begin{minted}{agda}
data _⇓_ : e₁ ⋎ e₂ -> ES₃ xs -> Set where
  nil : nil ⇓ []
  merge : f ⊔ g ↧ h -> p ⇓ e₃ -> (cons f g p) ⇓ (h ∷ e₃)
  conflict : f ⊔ g ↥ c -> p ⇓ e₃ -> (cons f g p) ⇓ (c ∷ᶜ e₃)
\end{minted}

	The data type is indexed over the global alignment proof object
	The following type synonym is used instead for greater clarity:
\begin{minted}{agda}
Diff₃ : (e₁ : ES xs ys) (e₂ : ES xs zs) {{p : e₁ ⋎ e₂}} -> ES₃ xs -> Set
Diff₃ _ _ {{p}} e₃ = p ⇓ e₃
\end{minted}
	The type \texttt{Diff₃ e₁ e₂ e₃} is the proof that \texttt{e₃} is the edit script
	produced by merging \texttt{e₁} and \texttt{e₂}. The alignment condition is 
	left implicit using	 an instance argument.	
	
	\subsection{Merged$_3$}
	\label{subsec:Merged3}
	Some of the properties discussed in sections \ref{subsec:Safety} and
	\ref{subsec:Embedding} are restricted only to successful \texttt{Diff₃}.
	This section presents the corresponding specifications.

	\paragraph{Definition}
	A \texttt{Diff₃} is considered \emph{successful} if the merged edit script
	does not contain any conflict and it is well-typed.
	In fact a script of type \texttt{ES₃ as} is by-construction 
	well-typed with respect to the source list \texttt{as}, 
	but it may not with respect to the output list.
	
\begin{minted}{agda}
data Merged₃ : ES xs ys -> ES xs zs -> ES xs ws -> Set where  
  nil : Merged₃ [] [] []
  cons : f ⊔ g ↧ h -> Merged₃ e₁ e₂ e₃ -> Merged₃ (f ∷ e₁) (g ∷ e₂) (h ∷ e₃)
\end{minted}

	Note that in \texttt{Merged₃} the third index is of type \texttt{ES},
	instead of \texttt{ES₃} as in \texttt{Diff₃}.
	It is important to point out that the absence of conflicts does not imply that 
	an edit script is well-typed.
	For example the following edit script is ill-typed:

\begin{minted}{haskell}
badExpr :: ES []
badExpr = Ins Add ∷ Ins One :: []
\end{minted}

	The script produces an ill-typed tree, because \texttt{Add} is 
	applied to only one expression.

	The typing judgment \texttt{e ⇒ as} states that the edit script  \texttt{e} 
	is well typed and produces a \texttt{DList as}.
	The typing rules are straightforward:
	
	\begin{center}	
		\mbox{	
				\AxiomC{}
				\UnaryInfC{\texttt{[] ⇒ []}}			
				\DisplayProof
		}
		\mbox{
				\AxiomC{\texttt{f : v \textasciitilde> w}}
				\AxiomC{\texttt{w : Val cs ds}}
				\AxiomC{\texttt{e ⇒ cs ++ ys}}
				\TrinaryInfC{\texttt{f ∷ e ⇒ (ds ++ ys)}}
				\DisplayProof
		}
	\end{center}
	
	A trivial inference algorithm can be easily deduced from the typing rules.
	Moreover note that the conflict cons constructor (\texttt{∷ᶜ}) is not 
	mentioned in the typing rules, therefore edit scripts containing
	conflicts are ill-typed.
		
	Edit scripts of type \texttt{ES₃} can be converted to \texttt{ES}, if they
	are well typed:

\begin{minted}{agda}
⌜_⌝  : (e : ES₃ xs) -> {{q : e ⇒ ys }}-> ES xs ys
\end{minted}

	The following theorems show that \texttt{Merged₃} is equivalent to
	\texttt{Diff₃} whose merged edit script is well-typed.

\begin{minted}{agda}
Merged₃-suf : Diff₃ e₁ e₂ e₃ -> e₃ ⇒ ws -> Merged₃ e₁ e₂ ⌜ e₃ ⌝
Merged₃-nec : Diff₃ e₁ e₂ e₃' -> Merged₃ e₁ e₂ e₃ -> e₃' ⇒ ws -> e₃ ≡ ⌜ e₃' ⌝
\end{minted}
	
	\paragraph{Discussion}
	It is worth pointing out that, contrary to textual tools, 
	the merger described in this thesis can fail 
	not only with value related conflicts, but also producing
	an ill-typed term.
	The choice of indexes for \texttt{Merged₃} is non trivial
	and already poses some interesting question:

\begin{minted}{agda}
data Merged₃ : ES as bs -> ES as cs -> ES as ? -> Set where
\end{minted}	
	What type list should be put instead of the question mark?
	Clearly when \texttt{bs ≡ cs}, the list \texttt{bs} is a good choice.
	However this assumption is too restrictive, because at some
	point the edit scripts may have different output types, but still there might 
	exist a most general type.
	A possible alternative would be to choose an asymmetric signature,
	so that the merged script always shares the output list with the first script.
\begin{minted}{agda}
data Merged₃ : ES as bs -> ES as cs -> ES as bs -> Set where
\end{minted}	
	Crucially also this choice is not satisfactory, because 
	there could be merges (\texttt{Id₁}), that follow the second script and its 
	types, which would clash with this choice.
	As a result there is no optimal a priori choice of type that would not
	be somehow restrictive. Therefore a completely
	unrelated type \texttt{ws} is given as output type and 
	a merged edit script must be typechecked to actually compute it, if one 
	exists.
				
	\subsection{Summary}
	This section has introduced the fundamental definitions
	of the formal model. Section \ref{subsec:DTree} shows an encoding of 	
	algebraic data types as heterogeneous rose trees, i.e.\ a combination of
	\texttt{DTree} and \texttt{DList}, whose nodes correspond
	to data type constructors. The edit script data type \texttt{ES xs ys} is a 
	well-typed list of edits, which 	transform a source object, a \texttt{DList xs} 
	given by \texttt{⟪ e ⟫}, in a \texttt{DList ys} given by \texttt{⟦ e ⟧}.
	The specifications of the \texttt{diff} algorithm are given by the 
	\texttt{Diff x y e} data type, which is proved to be in a one to one 
	relationship with \texttt{Diff ⟪ e ⟫ ⟦ e ⟧ e}.
	Section \ref{subsec:Merge} defines the notion of \emph{aligned} edit 
	scripts, for which a consistent merge semantics	is given. It consists of two
	data types: \texttt{f ⊔ g ↧ h} denotes a successful merge
	resulting in the edit \texttt{h}, while \texttt{f ⊔ g ↥ c} denotes
	two irreconcilable edits that raise a conflict.
	The binary operator \texttt{⊔} merges two aligned edit, producing
	either of the two proofs.
	After extending the alignment conditions to whole edit scripts 
	(\texttt{e₁ ⋎ e₂}) the specifications of the \texttt{diff3} algorithm
	are given in terms of the \texttt{Diff₃ e₁ e₂ e₃} data type.
	The result of \texttt{diff3} is of type \texttt{ES₃ xs},
	a variant of the previous edit script that may contain
	conflicts and that is type safe only with respect to the input list.
	Lastly the \texttt{Merged₃ e₁ e₂ e₃} type refines \texttt{Diff₃ e₁ e₂ e₃}
	restricting \texttt{e₃} to be conflictless and well-typed with respect to the
	output list.
		
\section{Algorithms}
This section presents the algorithms \texttt{diff} and \texttt{diff3} and proves that they satisfy the specifications embodied respectively by \texttt{Diff} and \texttt{Diff₃}.

	\subsection{Diff}
	\label{subsec:AlgoDiff}
	A \texttt{diff} algorithm takes as input two objects 
	and outputs an edit script that reports the differences between them.
	It is convenient to model the edit script as a list of instructions that
	transform the the first object, named \emph{source}, into the second,
	named \emph{target}, applying edit operations to their nodes.
	Furthermore \texttt{diff} finds a \emph{minimal length} edit script, or
	equivalently the \emph{longest common subsequence} of its inputs
	\cite{Berg00, PierceDiff3}.
	Conventionally edit scripts employ only delete, insert and copy operations,
	however the model presented here slightly deviates, therefore an 
	appropriate cost function is defined.

\begin{minted}{agda}
cost : ES as bs -> ℕ
cost (Nop ∷ e) = 1 + cost e
cost (Del α ∷ e) = 1 + cost e
cost (Ins α ∷ e) = 1 + cost e
cost (Upd α β ∷ e) = distance α β + cost e 
cost [] = 0
\end{minted}

	The edit \texttt{Nop} has weight one, even though it has
	no operational effect, because it does increase the length of 
	an edit script. In other words for any edit script that contains
	some \texttt{Nop} an equivalent script with smaller cost can be obtained
	by removing each \texttt{Nop} edit.	
	The function \texttt{distance} weights the difference between two nodes 
	and it is expected to be a \emph{metric} on the set of nodes.

	\paragraph{Metric}
	\label{par:Metric}
	A metric on a set $A$ is a function $d	 : (A \times A) \rightarrow \mathbb{R}$
	such that $\forall x, y, z \in A$:
	\begin{align*}
		d(x, y) &\geq 0 \quad &\mbox{\emph{{(non-negativity)}}}\\ 
		d(x, y) &= 0 \Leftrightarrow x = y \quad &\mbox{\emph{(coincidence axiom)}} \\		
		d(x, y) &= d(y, x) \quad &\mbox{\emph{(symmetry)}}\\
		d(x, z) &\leq d(x, y) + d(y, z) \quad &\mbox{\emph{(triangle inequality})}
	\end{align*}
	
	A reasonable choice for \texttt{distance} is the \emph{discrete distance}:
	\[ d(x, y) = 
		\begin{cases} 
			0 \quad &\mbox{if } x = y \\
			1 \quad &\mbox {otherwise}		
		\end{cases} \]
	
	The binary operator \texttt{\_⨅\_} returns the edit script that minimizes 	
	\texttt{cost}. Its implementation is straightforward and thus omitted.

\begin{minted}{agda}
_⨅_ : ES as bs -> ES as bs -> ES as bs
\end{minted}

	The algorithm proceeds as follows:

\begin{minted}{agda}
diff : DList as -> DList bs -> ES as bs
diff [] [] = []
diff [] (Node β ys₁ ∷ ys₂) = Ins β ∷ diff [] (ys₁ +++ ys₂)
diff (Node α xs₁ ∷ xs₂) [] = Del α ∷ diff (xs₁ +++ xs₂) []
diff (Node α xs₁ ∷ xs₂) (Node β ys₁ ∷ ys₂) with eq? α β
... | yes refl = Del α ∷ diff (xs₁ +++ xs₂) (Node β ys₁ ∷ ys₂) 
             ⨅ Ins β ∷ diff (Node α xs₁ ∷ xs₂) (ys₁ +++ ys₂) 
             ⨅ Upd α β ∷ diff (xs₁ +++ xs₂) (ys₁ +++ ys₂)
... | no a≠b  = Del α ∷ diff (xs₁ +++ xs₂) (Node β ys₁ ∷ ys₂) 
              ⨅ Ins β ∷ diff (Node α xs₁ ∷ xs₂) (ys₁ +++ ys₂)
\end{minted}
	
	When one of the input list is empty the other is consumed 
	by applying repeatedly either the \texttt{Ins} or \texttt{Del} edit
	to the nodes left. When both are non empty there are three
	alternatives. Either the input node can be consumed by \texttt{Del},
	or the output node can be consumed by \texttt{Ins}, or, if
	the two nodes have the same type, the first can be mapped into
	the second by \texttt{Upd}. Among these options, the best 
	script is selected using the \texttt{⨅} operator.
	Note that the \texttt{Nop} edit is never used because it does
	not consume neither of the two lists: no progress can be made with it.

	The algorithm implemented in this way is very inefficient,
	because it contains several recursive calls that perform the same 
	sub-computations multiple times. 
	The algorithm can be made practical with memoization \cite{Lemp09},
	however the focus here is on correctness, rather than computational 
	complexity, 	therefore the simpler version will be used.
	
	\paragraph{Technical remark}
	Agda is a total language and therefore requires all the functions to 
	terminate. Since termination is in general undecidable, Agda's termination 
	checker accepts only structural recursion, which safely guarantees
	termination. In this case \texttt{diff} is rejected as possibly 
	non-terminating, because it is not structurally recursive
	due to the presence of \texttt{+++} in the arguments. 
	In the actual model, to overcome this limitation, the function has been 
	adjusted to include an additional parameter, which is an upper-bound 
	on the number of nodes contained in the source and target lists.
	
\begin{minted}{agda}
size : DList as -> ℕ 
size [] = 0
size (Node α xs ∷ ys) = 1 + size xs + size ys

sdiff : {n : ℕ} (xs : DList as) (ys : DList bs) -> size xs + size ys ≤ n -> ES as bs
\end{minted}
	
	The implementation of \texttt{sdiff} (sized diff) is the same, but recursive 
	calls	are structurally recursive on the upper-bound proof object.
	Minor lemmas that show that \texttt{size} distributes over \texttt{+++}
	are needed to prove that the number of nodes yet to be processed
	is strictly decreasing in the last case.

	The function \texttt{diff} then simply calls \texttt{sdiff} using an appropriate
	upper bound.
		
\begin{minted}{agda}
diff : DList as -> DList bs -> ES as bs
diff xs ys = sdiff {n = size xs + size ys} xs ys (≤-refl (size xs + size ys))
\end{minted}

	The function \texttt{≤-refl} states that the relation \texttt{≤} is 
	\emph{reflexive}, i.e.\ for any \texttt{n} it follows that \texttt{n ≤ n}.
	The proof is by induction on \texttt{n}.	 

	\paragraph{Sufficient}
	The lemma used to relate \texttt{Diff xs ys e} and \texttt{diff xs ys e} 
	is the following:
\begin{minted}{agda}	
Diff-suf : ∀ (xs : DList as) (ys : DList bs) -> Diff xs ys (diff xs ys)
\end{minted}

	Since \texttt{diff} simply calls \texttt{sdiff} 	 the actual proof is 
	by induction on the upper-bound and closely follows its
	structure. The proof is not particularly interesting and therefore omitted.

	The theorem intuitively holds because any edit script \texttt{e} that maps 
	\texttt{xs} into \texttt{ys} satisfies \texttt{Diff xs ys e}.
	The \texttt{diff} algorithm computes one of them and in particular the one
	with minimal length. 
	However note that \texttt{Diff xs ys e} does not imply that
	that \texttt{e ≡ diff xs ys}, because it does not force \texttt{e} to be 
	of minimal length.
	Choosing a weaker specification was an aware design decision:
	all the properties considered in the model hold regardless of 
	the fact that the scripts are optimal. The advantage
	of this choice is that at any time it is possible to change the \texttt{diff}
	algorithm and the relative properties would still be valid.
	For example an heuristic that quickly finds a suboptimal edit script 
	may be employed to meet certain performance requirements.
	
	\paragraph{Discussion}
	To minimize the cost function, the \texttt{diff} algorithm strives to 
	match equal nodes, because they have the least distance, similarly to 
	what happens in common diff algorithms \cite{Lemp09}.
	An update involving different nodes is preferred to the equivalent 
	insert and consecutive deletion. This crucial aspect will be explained
	in section \ref{subsec:diff3}.
	The no-operation is never preferred, because it consumes neither the
	source or the target object, but increases the cost of an edit-script.
	The reason behind introducing this superfluous edit operation	will be 
	clarified in \ref{subsec:diff3}.

	\subsection{Diff$_3$}
	\label{subsec:diff3}	
	This section introduces the \texttt{diff₃} algorithm used to compare 
	three objects, one of which is considered a previous common version
	of the other two.
	Similarly to GNU diff3, the algorithm takes as input three objects
	and outputs an edit script that combines the changes between them.
	Likewise the algorithm does not operate on the objects directly,
	but rather calls the \texttt{diff} subroutine twice to detected the changes 
	from the common version to the others.
	It then merges the two edit scripts so obtained to produce an edit script
	that combines both.
	
	The core function is \texttt{merge₃} which combines two 
	\emph{aligned} edit scripts, applying the \texttt{⨆} operator to
	each pair of aligned edits. 
\begin{minted}{agda}
merge₃ : {e₁ : ES as bs} {e₂ : ES as cs} -> e₁ ⋎ e₂ -> ES₃ as
merge₃ nil = []
merge₃ (cons f g p) with f ⨆ g
merge₃ (cons f g p) | inj₁ (c , _) = c ∷ᶜ merge₃ p
merge₃ (cons f g p) | inj₂ (h , _) = h ∷  merge₃ p
\end{minted}
	
	To improve readability the following entry point for \texttt{merge₃} is
	defined:
\begin{minted}{agda}
_⨆₃_ (e₁ : ES as bs) (e₂ : ES as cs) {{p : e₁ ⋎ e₂} -> ES₃ as
_⨆₃_  _ _ {{p}} = merge₃ p
\end{minted}
	
	\paragraph{Sufficient}
	The next result shows that \texttt{⨆₃} satisfies
	the specifications set by \texttt{Diff₃}.
	
\begin{minted}{agda}
Diff₃-suf : {e₁ : ES as bs} {e₂ : ES as cs} (p : e₁ ⋎ e₂) -> Diff₃ e₁ e₂ (e₁ ⨆₃ e₂)
\end{minted}
	The proof follows immediately by induction 
	on \texttt{e₁ ⋎ e₂}.

	\paragraph{Complete}
	The following theorem proves that the algorithm is
	complete with respect to the specification, i.e.\ that
	for any triplet of edit scripts \texttt{e₁ e₂ e₃} that satisfies 
	the \texttt{Diff₃} specifications, the merged
	edit script \texttt{e₃} is the result of \texttt{e₁ ⨆₃ e₂}.
	
	The proof is short, but interesting, therefore it will
	be reported in full.
	
\begin{minted}{agda}
Diff₃-nec : Diff₃ e₁ e₂ e₃ -> e₃ ≡ e₁ ⨆₃ e₂
Diff₃-nec nil = refl
Diff₃-nec (merge {f = f} {g = g} m q) with f ⨆ g
Diff₃-nec (merge m q) | inj₁ (c , u) = ⊥-elim (mergeConflictExclusive m u)
Diff₃-nec (merge m q) | inj₂ (h' , m') with mergeDeterministic m m'
Diff₃-nec (merge m q) | inj₂ (h' , m') | refl = cong (_∷_ h') (Diff₃-nec q)
Diff₃-nec (conflict {f = f} {g = g} u q) with f ⨆ g
Diff₃-nec (conflict u q) | inj₁ (c , u') with conflictDeterministic u u'
Diff₃-nec (conflict u q) | inj₁ (c , u') | refl = cong (_∷ᶜ_ c) (Diff₃-nec q)
Diff₃-nec (conflict u q) | inj₂ (h , m) = ⊥-elim (mergeConflictExclusive m u)	
\end{minted}

	The proof is by induction on \texttt{Diff₃ e₁ e₂ e₃}.
	The equivalence is immediate in the base case	, when both
	\texttt{e₁} and \texttt{e₂} are empty edit script (\texttt{nil}).
	In the first recursive case (\texttt{merge}), there are 
	two \emph{aligned} edits \texttt{f} and \texttt{g} that are
	merged in \texttt{h}, since \texttt{m} has type \texttt{f ⊔ g ↧ h}.
	The goal is the equivalence \texttt{h ∷ e₃ ≡ (f ∷ e₁) ⨆₃ (g ∷ e₂)}. By inductive 
	hypothesis (\texttt{Diff₃-nec q}), it follows that \texttt{e₃ ≡ e₁ ⨆ e₂}, so
	the only proof obligation left is to show that \texttt{f ⨆ g ≡ h}.
	By case analysis, either \texttt{f ⨆ g} fails raising a conflict or it succeeds
	producing a merged edit \texttt{h'}.
	The first case is discharged by contradiction: merges and conflicts
	are mutually exclusive.
	The second case requires to show that the proofs \texttt{m : f ⊔ g ↧ h}
	and \texttt{m' : f ⊔ g ↧ h'} imply that \texttt{h ≡ h'}.
	This follows from the property that \texttt{⊔} is deterministic 
	\cite{AlgebraOfProgramming}, i.e.\ same inputs lead to same outputs.
	A similar line of reasoning applies in the second recursive
	case (\texttt{conflict}), in which conflicts determinism
	is used instead.
	
	The lemmas used in the proof are reported here for completeness.

	\paragraph{Mutual exclusion}
	\label{par:MutualExclusion}
	The lemma \texttt{mergeConflictExclusive} asserts that two aligned edits
	are \emph{exclusively} conflicting or reconcilable.
	
\begin{minted}{agda}
mergeConflictExclusive : f ⊔ g ↧ h -> ¬ (f ⊔ g ↥ c)
mergeConflictExclusive (Id₁ f g) (UpdUpd .f .g α≠β α≠γ β≠γ) = α≠β refl
mergeConflictExclusive (Id₁ f g) (UpdDel .f .g α≠β) = α≠β refl
mergeConflictExclusive (Id₂ f g) (UpdUpd .f .g α≠β α≠γ β≠γ) = α≠γ refl
mergeConflictExclusive (Id₂ f g) (DelUpd .f .g α≠β) = α≠β refl
mergeConflictExclusive (Idem f) (InsIns f f α≠β) = α≠β refl
mergeConflictExclusive (Idem f) (UpdUpd f f α≠β α≠γ β≠γ) = β≠γ refl
	\end{minted}
	
	The proof is by contradiction.
	Since \texttt{¬ (f ⊔ g ↥ c)} is short for \texttt{f ⊔ g ↥ c -> ⊥},
	one additional parameter of type \texttt{f ⊔ g ↥ c} is included.
	From \texttt{f ⊔ g ↧ h} and \texttt{f ⊔ g ↥ c}, falsity (\texttt{⊥})
	has to be produced. 
	
	Case analysis on the two terms leads to incongruent conclusions.
	Let us examine the first one as an example, the others follow from 
	similar considerations.
	The term \texttt{UpdUpd f g α≠β α≠γ β≠γ} asserts that 
	\texttt{f} has type \texttt{⟨ α ⟩ \textasciitilde> ⟨ β ⟩} for some 
	nodes \texttt{α} and \texttt{β}. Moreover the term
	\texttt{α≠β} claims that \texttt{¬ (α ⋍ β)}, or equivalently
	\texttt{α ⋍ β -> ⊥}.
	In the term \texttt{Id₁ f g}, the edit \texttt{f} 
	has type \texttt{v \textasciitilde> v} for any value \texttt{v}. Since these 
	terms have types	\texttt{f ⊔ g ↧ h} and \texttt{f ⊔ g ↥ c}, their edits 
	\texttt{f} are the same, hence their types are unified, assigning the most 
	general type \texttt{⟨ α ⟩ \textasciitilde> ⟨ α ⟩} to \texttt{f}.
	As a consequence \texttt{β} is actually \texttt{α}, then \texttt{α≠β}
	has type \texttt{α ⋍ α -> ⊥}. By reflexivity (\texttt{refl}), \texttt{α ⋍ α} for
	any \texttt{α}, then applying \texttt{α≠β} to it produces \texttt{⊥}.
	
	\paragraph{Determinism}
	\label{par:Determinism}
	Even though the \texttt{⊔} operator is a binary \emph{function}, 
	in the data types \texttt{f ⊔ g ↧ h} and \texttt{f ⊔ g ↥ c}, the symbol
	\texttt{⊔} is just a part of their identifiers, and as such as nothing to
	do with the \texttt{⊔} operator.
	These data types merely represents \emph{ternary relations} over their 
	indexes and may or may not be functional.
	This property has to proved for each of them.
	
	The structure of the proof is standard and requires to show that for any 
	pair of triplets $(x, y, z_1)$ and $(x, y, z_2)$ satisfying
	the relation, it follows that $z_1 = z_2$.
	
\begin{minted}{agda}
mergeDeterministic : f ⊔ g ↧ h₁ -> f ⊔ g ↧ h₂ -> h₁ ≡ h₂
mergeDeterministic (Id₁ f g) (Id₁ .f .g) = refl
mergeDeterministic (Id₁ f g) (Id₂ .f .g) = edit-≡ g f
mergeDeterministic (Id₁ f .f) (Idem .f) = refl
mergeDeterministic (Id₂ f g) (Id₁ .f .g) = edit-≡ f g
mergeDeterministic (Id₂ f g) (Id₂ .f .g) = refl
mergeDeterministic (Id₂ f .f) (Idem .f) = refl
mergeDeterministic (Idem f) (Id₁ .f .f) = refl
mergeDeterministic (Idem f) (Id₂ .f .f) = refl
mergeDeterministic (Idem f) (Idem .f) = refl
\end{minted}

	The proof follows almost directly from case analysis on the two arguments.
	It is immediate when either the two constructors is \texttt{Idem}, because
	it implies that \texttt{f ≡ g ≡ h}, and when the two constructors are the 
	same (\texttt{Id₁} and \texttt{Id₁}, \texttt{Id₂} and \texttt{Id₂}).
	In the spurious cases left (\texttt{Id₁} and \texttt{Id₂}), the goal
	is to show that \texttt{f ≡ g} 
	given that they both have type \texttt{v \textasciitilde> v}.
	The following lemma shows that two identity edits that shares the same 
	value are indeed equal.
	
\begin{minted}{agda}
edit-≡ : (f g : v ~> v) -> f ≡ g
edit-≡ Nop Nop = refl
edit-≡ (Upd α .α) (Upd .α .α) = refl
\end{minted}	
	
	The proof for \texttt{f ⊔ g ↥ c} follows directly from case analysis on the 
	arguments:
	
\begin{minted}{agda}
conflictDeterministic : f ⊔ g ↥ c₁ -> f ⊔ g ↥ c₂ -> c₁ ≡ c₂
conflictDeterministic (InsIns f g α≠β) (InsIns .f .g α≠β₁) = refl
conflictDeterministic (UpdUpd f g α≠β α≠γ β≠γ) (UpdUpd .f .g α≠β₁ α≠γ₁ β≠γ₁) = refl
conflictDeterministic (UpdDel f g α≠β) (UpdDel .f .g α≠β₁) = refl
conflictDeterministic (DelUpd f g α≠β) (DelUpd .f .g α≠β₁) = refl
\end{minted}	


	In order to use the \texttt{⨆₃} operator previously defined, an alignment
	proof \texttt{e₁ ⋎ e₂} is needed.
	If two edit scripts share the same source object, they both will include 
	edits that process its nodes. Furthermore, since edit scripts work 
	in a depth first order, these edits will be found in each 
	of the two edit scripts in the same order.
	Unfortunately this is not enough to conclude that the two edit scripts 
	are completely aligned, since inserts may occur at any point.
		
	Nevertheless it is possible to realign the two edit scripts, inserting
	a finite number of \texttt{Nop} edits.	
	It is important to emphasize that, an edit script extended in this way
	does not affect its semantics with respect to the source and target function.
	Intuitively this is correct, since the \texttt{Nop} edit has no effect at all
	in those functions.
	The following preliminary definitions put this property on a formal footing.

	\paragraph{Extension}
	\label{par:Extension}
	The statement \texttt{e₁ ⊴ e₂} means that \texttt{e₂} extends \texttt{e₁}
	introducing a finite number of \texttt{Nop} edits.
	
\begin{minted}{agda}
data _⊴_ : ES as bs -> ES as bs -> Set where
  stop : [] ⊴ []
  cons : (f : v ~> w) -> e₁ ⊴ e₂ -> f ∷ e₁ ⊴ f ∷ e₂
  nop : e₁ ⊴ e₂ -> e₁ ⊴ Nop ∷ e₂
\end{minted}
		
	The following lemmas show that the extended script is 
	indistinguishable from the original one, with respect to
	the source and target function.
	
\begin{minted}{agda}
⊴-⟪_⟫ : e₁ ⊴ e₂ -> ⟪ e₁ ⟫ ≡ ⟪ e₂ ⟫
⊴-⟦_⟧ : e₁ ⊴ e₂ -> ⟦ e₁ ⟧ ≡ ⟦ e₂ ⟧
\end{minted}

	The proofs are by induction on \texttt{e₁ ⊴ e₂} and rely on the fact that
	\texttt{Nop} affect neither \texttt{⟪\_⟫} nor \texttt{⟦\_⟧}.
	
	The relation \texttt{e₁ \textasciitilde\ e₂} asserts that there are
	extensions of \texttt{e₁} and \texttt{e₂}, which are \emph{aligned}.
	
\begin{minted}{agda}
data _~_ (e₁ : ES as bs) (e₂ : ES as cs) : Set where
  Align : e₁ ⊴ e₁' -> e₂ ⊴ e₂' -> e₁' ⋎ e₂' -> e₁ ~ e₂
\end{minted}
	
	It is possible to show that such extensions exist for any \texttt{e₁} 
	and \texttt{e₂} 	originated from the same source. 
	
\begin{minted}{agda}
Diff⋎ : Diff as bs e₁ -> Diff as cs e₂ -> e₁ ~ e₂
\end{minted}
	The function is defined by induction on the two arguments,
	but, because of the number of uninteresting cases, it is lengthy 
	and therefore omitted.

	\paragraph{Diff$_3$}
	Now it is possible to provide the conventional \texttt{diff₃} interface, in
	which the second object is considered the old common version:
\begin{minted}{agda}
diff₃ : DList bs -> DList as -> DList cs -> ES₃ as
diff₃ ys xs zs with Diff⋎ (Diff-suf xs ys) (Diff-suf xs zs)
diff₃ ys xs zs | Align _ _ p = merge₃ p
\end{minted}
	
	The \texttt{diff} algorithm is called implicitly by \texttt{Diff-suf}; the
	edit scripts so obtained are aligned via extension using 
	\texttt{Diff⋎}, from which the alignment proof \texttt{p} is extracted
	and used to finally merge the scripts with \texttt{merge₃}.
	Note that the call to \texttt{Diff⋎} is valid because \texttt{Diff-suc}
	is invoked with the same \texttt{xs} as first argument.
	
\section{Formal Properties}
\label{sec:FormalProp}
In this section we will study some properties of the algorithms presented. As pointed out in \ref{subsec:spec}, the 
properties will be proved using the specifications of the algorithms, rather
than the algorithms themselves, so that the proofs will be simpler and 
furthermore valid for any algorithm satisfying those specifications.
The advantages gained with these additional properties
are evident: the model becomes stronger, more reliable and predictable.

	\subsection{Conflicts}
	\label{subsec:conflicts}
		In order to safely reason about complex merging operations, 
		the necessary and sufficient conditions required to trigger a conflict are 
		pinpointed.

		Firstly, some auxiliary definitions will be introduced.
\begin{minted}{agda}
data _∈ᶜ_ : Conflict u v w -> ES₃ xs -> Set₁ where
  here : (c : Conflict u v w) -> c ∈ᶜ (c ∷ᶜ e)
  there : c ∈ᶜ e -> c ∈ᶜ f ∷ e
  thereᶜ : (c' : Conflict u' v' w') -> c ∈ᶜ e -> c ∈ᶜ (c' ∷ᶜ e)
\end{minted}

		The type \texttt{c ∈ᶜ e} denotes that some conflict \texttt{c}
		is present in the edit script \texttt{e}.

		Given \texttt{Diff₃ e₁ e₂ e₃} this section aims to find the sufficient and 
		necessary conditions on \texttt{e₁} and \texttt{e₂}, or more concisely
		on \texttt{e₁ ⋎ e₂}, such that \texttt{c ∈ᶜ e₃}.	
		Since conflicts are triggered by incompatible \emph{aligned} edits
		and more specifically depend on the three values they involve,
		a data type to refer to 	them is needed:
\begin{minted}{agda}
data Map⋎ (u : Val as bs) (v : Val cs ds) (w : Val es fs) 
          : e₁ ⋎ e₂ -> Set where
  here : (f : u ~> v) (g : u ~> w) -> Map⋎ u v w (cons f g p) 
  cons : (f : u' ~> v') (g : u' ~> w') -> Map⋎ u v w p -> Map⋎ u v w (cons f g p)
\end{minted}
	Note that \texttt{Map⋎ u v w p} is parametric in the values \texttt{u}, 
	\texttt{v} and \texttt{w}.
		
	A better looking syntax is introduced with a type synonym, mainly
	to leave the alignment proof implicit, but also to rearrange the order
	of the parameters and indexes, since in declarations parameters
	always precede indexes.
	
\begin{minted}{agda}
_,_⊢_~>[_,_] : (e₁ : ES xs ys) (e₂ : ES xs zs) {{p : e₁ ⋎ e₂}} -> 
                  (u : Val as bs) (v : Val cs ds) (w : Val es fs) -> Set
_,_⊢_~>[_,_] e₁ e₂ {{p}} u v w = Map⋎ u v w p
\end{minted}

	The statement \texttt{e₁ , e₂ ⊢ u \textasciitilde>[ v , w ]} means that, given
	\texttt{e₁} and \texttt{e₂}, their aligned source value \texttt{u} is mapped
	respectively to \texttt{v} in \texttt{e₁} and to \texttt{w} in \texttt{e₂}.

	The minimal conditions for the presence of conflicts are represented
	by:
\begin{minted}{agda}
data Failure (p : e₁ ⋎ e₂) : Conflict u v w -> Set where
  InsIns : (α : F as a) (β : F bs b) -> e₁ , e₂ ⊢ ⊥ ~>[ ⟨ α ⟩ , ⟨ β ⟩ ] ->
          (α≠β : ¬ (α ⋍ β)) -> Failure p (InsIns α β)
  UpdUpd : (α : F as a) (β : F bs a) (γ : F cs a) -> 
             e₁ , e₂ ⊢ ⟨ α ⟩ ~>[ ⟨ β ⟩ , ⟨ γ ⟩ ] ->
             (α≠β : ¬(α ⋍ β)) (α≠γ : ¬ (α ⋍ γ)) (β≠γ : ¬(β ⋍ γ)) -> 
             Failure p (UpdUpd α β γ)
  UpdDel : (α : F as a) (β : F bs a) -> e₁ , e₂  ⊢ ⟨ α ⟩ ~>[ ⟨ β ⟩ , ⊥ ] ->
            (α≠β : ¬(α ⋍ β)) -> Failure p (UpdDel α β)
  DelUpd : (α : F as a) (β : F bs a) -> e₁ , e₂  ⊢ ⟨ α ⟩ ~>[ ⊥ ,  ⟨ β ⟩ ] ->
             (α≠β : ¬(α ⋍ β)) -> Failure p (DelUpd α β)
\end{minted}

	A value of type \texttt{Failure p c} denotes that in \texttt{p} there are
	two aligned edits that are incompatible and will trigger the conflict 
	\texttt{c}.
	Few observations are in order.
	Firstly \texttt{Failure} is parametric on \texttt{p} of type \texttt{e₁ ⋎ e₂}, 
	which brings into scope \texttt{e₁}, \texttt{e₂} and the alignment proof 
	\texttt{p} demanded 
	implicitly by \texttt{ e₁ , e₂ ⊢ u \textasciitilde>[ v , w ]}.
	Secondly the conflict \texttt{c} is instead an index, since it must be
	instantiated properly with a different conflict by each constructor.
	Lastly the inequalities and the conflicting edits specified by each 
	constructor are consistent with those from \texttt{f ⊔ g ↥ c}, just lifted to
	edit scripts.

	Once more a type synonym is used for readability:
\begin{minted}{agda}
_,_↥_ : (e₁ : ES xs ys) (e₂ : ES xs zs) {{p : e₁ ⋎ e₂}} -> Conflict u v w -> Set
_,_↥_ e₁ e₂ {{p}} c = Failure p c 
\end{minted}
	
	\paragraph{Necessary}
	\label{par:ConflictNec}
	The following theorem asserts that if \texttt{e₃} merges \texttt{e₁} and
	\texttt{e₂} and \texttt{c ∈ᶜ e₃}, then it follows that \texttt{e₁ ,e₂ ↥ c}.
	
\begin{minted}{agda}
conflict-nec : c ∈ᶜ e₃ -> Diff₃ e₁ e₂ e₃ -> e₁ , e₂ ↥ c
\end{minted}

	The proof is by straightforward induction and thus omitted.

	\paragraph{Sufficiency}
	The converse theorem is slightly more involved.
	The proof is also by induction, but some of the base cases requires further 
	inspection to be discharged by contradiction.
	The structure is the same for each kind of conflict, therefore only the
	proof for one of them is listed here.
	
\begin{minted}{agda}
conflict-suf : e₁ , e₂ ↥ c -> Diff₃ e₁ e₂ e₃ -> c ∈ᶜ e₃
conflict-suf (InsIns α .α (here y .y) α≠β) (merge (Idem .y) d) = ⊥-elim (α≠β refl)
conflict-suf (InsIns α β (here x y) α≠β) (conflict (InsIns .x .y α≠β₁) d) 
  = here (InsIns α β)
conflict-suf (InsIns α β (cons x y q) α≠β) (merge m d) 
  = there _ (conflict-suf (InsIns α β q α≠β) d)
conflict-suf (InsIns α β (cons x y q) α≠β) (conflict u d) 
  = thereᶜ _ (conflict-suf (InsIns α β q α≠β) d)
\end{minted}

The \texttt{e₁ , e₂ ↥ c} data type only reveals the kind of conflict involved,
therefore the argument \texttt{e₁ , e₂ ⊢ u \textasciitilde>[ v , w ]} 
is further inspected.
The \texttt{cons}  constructor is stripped in the recursive 
calls and the appropriate \texttt{there} constructor is chosen depending on 
the value of \texttt{Diff₃}, in particular \texttt{there} in conjunction with 
\texttt{merge} and \texttt{thereᶜ} with \texttt{conflict}.
Both \texttt{conflict} and \texttt{merge} show up in the base cases, but only
the former is expected.
The presence of the latter is bogus: a conflict should occur, yet merge is reported. Two inserts can only be merged if they insert the same node \texttt{α}, but this contradicts \texttt{α≠β}, the proof stored in 
\texttt{e₁ , e₂ ↥ c}, which asserts that they are in fact different.

	\subsection{Safety}
	\label{subsec:Safety}
	This section introduces some safety requirements for the \texttt{Diff}
	and \texttt{Diff₃} data type, which act as sanity checks. 
	Firstly some preliminaries definitions are given, which 
	are then used to state and prove these properties. 
		
	\paragraph{Membership}
	\label{par:membership}
	The type \texttt{α ∈ ts} denotes that the node \texttt{α} is present
	in the list of trees \texttt{ts}.

\begin{minted}{agda}
data _∈_ : ∀ {ys xs a} -> F xs a -> DList ys -> Set where
  here : (α : F as a) -> α ∈ Node α ts₁ ∷ ts₂
  there : α ∈ ts₁ +++ ts₂ -> α ∈ Node β ts₁ ∷ ts₂
\end{minted}

A similar data type denotes membership of an edit in a script.

\begin{minted}{agda}
data _∈ₑ_ : v ~> w -> ES xs ys -> Set where
  here : (f : v ~> w) -> f ∈ₑ f ∷ e
  there : (g : w ~> z) -> f ∈ₑ e -> f ∈ₑ g ∷ e
\end{minted}
	
	The following wrapper data type will be often used for the 
	safety properties.
	The judgment \texttt{e ⊢ₑ u \textasciitilde> v} means that in 
	\texttt{e} the value \texttt{u} is mapped to \texttt{v}. 

\begin{minted}{agda}
data _⊢ₑ_~>_  (e : ES xs ys) : Val as bs -> Val cs ds -> Set where
  Nop : Nop ∈ₑ e -> e ⊢ₑ ⊥ ~> ⊥
  Del : (α : F as a) -> Del α ∈ₑ e -> e ⊢ₑ ⟨ α ⟩ ~> ⊥
  Ins : (α : F as a) -> Ins α ∈ₑ e -> e ⊢ₑ ⊥ ~> ⟨ α ⟩
  Upd : (α : F as a) (β : F bs a) -> Upd α β ∈ₑ e -> e ⊢ₑ ⟨ α ⟩ ~> ⟨ β ⟩ 
\end{minted}

	
%	The following auxiliary function is defined by induction on it:
%	\todo{remove if never mentioned}
%\begin{minted}{agda}
%there~> : e ⊢ₑ v ~> w -> f ∷ e ⊢ₑ v ~> w
%\end{minted}
	
	\paragraph{Core Properties}
	By induction it is possible to relate membership proofs on edit scripts
	with those about lists of trees.
	
\begin{minted}{agda}
∈-⟦⟧ : {f : v ~> ⟨ α ⟩} -> f ∈ₑ e -> α ∈ ⟦ e ⟧ 
∈-⟪⟫ : {f : ⟨ α ⟩ ~> v} -> f ∈ₑ e -> α ∈ ⟪ e ⟫
\end{minted}

	It is easy to restrict the edits only to those with, respectively, a target and
	a source node, giving an appropriate type to the edit \texttt{f}.

	These functions are also used to draw the same conclusions with the 
	judgment type:
\begin{minted}{agda}
targetOrigin : e ⊢ₑ v ~> ⟨ α ⟩ -> α ∈ ⟦ e ⟧
targetOrigin (Upd α β x) = ∈-⟦⟧ x
targetOrigin (Ins α x) = ∈-⟦⟧ x

sourceOrigin : e ⊢ₑ ⟨ α ⟩ ~> v -> α ∈ ⟪ e ⟫
sourceOrigin (Upd α β x) = ∈-⟪⟫ x
sourceOrigin (Del α x) = ∈-⟪⟫ x
\end{minted}

	\paragraph{Diff Safety}
	These properties are specific to the edit script data type and the source and 
	target functions.
	Furthermore, since \texttt{Diff x y e} is equivalent
	to \texttt{Diff ⟪ e ⟫ ⟦ e ⟧ e}, as showed in section \ref{subsec:Diff},
	also \texttt{Diff} shares the same properties.
	
\begin{minted}{agda}
noTargetMadeUp : e ⊢ₑ v ~> ⟨ α ⟩ -> Diff x y e -> α ∈ y 
noTargetMadeUp p q rewrite mkDiff⟦ q ⟧ = targetOrigin p

noSourceMadeUp : e ⊢ₑ ⟨ α ⟩ ~> v -> Diff x y e -> α ∈ x 
noSourceMadeUp p q rewrite mkDiff⟪ q ⟫ = sourceOrigin p
\end{minted}

	These propositions assert that any target and
	source node in a script comes, respectively, from the target and
	source object diffed by the edit script itself.
	
	The converse proposition states that a node \texttt{α} that belongs
	to the target (source) object, is to be found as target (source) value 
	in some edit in the script that converts the former to the latter.

	%\todo{better name noSourceForget?}
\begin{minted}{agda}
noSourceErase : Diff x y e -> α ∈ x -> ∃ (λ v -> e ⊢ₑ ⟨ α ⟩ ~> v)
noTargetErase : Diff x y e -> α ∈ y -> ∃ (λ v -> e ⊢ₑ v ~> ⟨ α ⟩) 
\end{minted}

	The proof is on induction on its arguments. Note that these proofs
	would be much more cumbersome, if stated directly 
	on \texttt{⟦ e ⟧} and \texttt{⟪ e ⟫}.
	
	\paragraph{Diff$_3$ Safety}
	\label{par:diff3-safety}
	The safety properties just discussed extend naturally to edits in the 
	\texttt{Diff₃} data type. Specifically an edit present in one of the input
	edit scripts will be found in the merged edit script, given that it does
	perform a change and that the output script does not contain conflicts.
	The first requirement is needed because identity edits can be silently 
	ignored in the merge semantics given by \texttt{f ⊔ g ↧ h}, with the
	constructors \texttt{Id₁} and   \texttt{Id₂}.
	On the other hand the second prerequisite is essential, because 
	\texttt{Diff₃} is \emph{persistent},
	i.e.\ it refuses to back out incompatible edits and instead triggers 
	an appropriate conflict.
	Before stating more formally the theorem, some simple auxiliary 
	data	types are introduced.

	Firstly an edit does perform a change if it is not the identity edit, or, in 
	other words	if the source and the target values are different.

\begin{minted}{agda}
data Change (f : v ~> w) : Set where
  IsChange : (v≠w : ¬ (v ≃ w)) -> Change f
\end{minted}

	Secondly the absence of conflicts in a script is guaranteed by 
	the following data type, that does not have any constructor that adds
	a conflict to the index.

\begin{minted}{agda}	
data NoCnf : ES₃ as -> Set where
  [] : NoCnf []
  _∷_ : (f : v ~> w) -> NoCnf e -> NoCnf (f ∷ e)
\end{minted}
			
	The theorem is firstly proved considering an edit present in
	the first input script (\texttt{f ∈ₑ e₁}).
	The result type \texttt{f ∈₃ e₃} proves the presence of the edit \texttt{f}
	in the merged script \texttt{e₃}. 
	It corresponds to \texttt{f ∈ e}, presented in 
	\ref{par:membership}, just indexed over a script of type \texttt{ES₃ as}
	instead of one of 	type \texttt{ES as bs}.
	
\begin{minted}{agda}
noBackOutChanges₁ : Change f -> Diff₃ e₁ e₂ e₃ -> f ∈ₑ e₁ -> NoCnf e₃ -> f ∈₃ e₃
\end{minted}
%noBackOutChanges₁ (IsChange v≠w) (merge (Id₁ f g) d) (here .f) _ = ⊥-elim (v≠w refl)
%noBackOutChanges₁ (IsChange v≠w) (merge (Id₂ f g ) d) (here .f) _ = here f
%noBackOutChanges₁ (IsChange v≠w) (merge (Idem f) d) (here .f) _ = here f
%noBackOutChanges₁ c (conflict u d) (here f) ()
%noBackOutChanges₁ c (merge m d) (there f₁ p) (h ∷ q) = there h (noBackOutChanges₁ c d p q)
%noBackOutChanges₁ c (conflict u₁ d) (there f₁ p₁) ()
%\end{minted}

	The theorem is proved by induction on \texttt{f ∈ₑ e₁} and 
	\texttt{Diff₃ e₁ e₂ e₃}.
%	In the base cases (\texttt{here}), the edit \texttt{f} may be merged or
%	it might raise a conflict. The latter case is contradictory: \texttt{NoCnf e₃}
%	excludes the presence of any conflict.
%	In the former case the merge data type is further inspected and produces 
%	three cases.
%	The first case (\texttt{Id₁}) is discharged as impossible because it 
%	contradicts \texttt{Change f}, which asserts that \texttt{f} is not identity.
%	The other two cases reveal that \texttt{f} is actually the merged edit
%	and thus it is present in \texttt{e₃}.
%	The \texttt{merge} recursive case is solved by inductive hypothesis, while
%	the \texttt{conflict} recursive case is dismissed as before.

	The same theorem holds for edits that belong to the second edit.
	
\begin{minted}{agda}
noBackOutChanges₂ : Change f -> Diff₃ e₁ e₂ e₃ -> f ∈ₑ e₂ -> NoCnf e₃ -> f ∈₃ e₃
noBackOutChanges₂ c d p q = noBackOutChanges₁ c (⇓-sym d q) p q
\end{minted}
	
	This is actually a corollary of the previous theorem, since
	\texttt{Diff₃} is symmetric in absence of conflicts.
	
\begin{minted}{agda}
⇓-sym : p ⇓ e₃ -> NoCnf e₃ -> (⋎-sym p) ⇓ e₃
⇓-sym nil _ = nil
⇓-sym (merge m p) (h ∷ q) = merge (↧-sym m) (⇓-sym p q)
⇓-sym (conflict u p) ()
\end{minted}	
	Note that this is not the case, when \texttt{e₃} does contain some conflicts,
	because the \texttt{Conflict} data type is asymmetric.
		
	The converse theorem asserts that any given edit in the merged script,
	comes from one of the input scripts.
	
\begin{minted}{agda}
noEditMadeUp : f ∈₃ e₃ -> Diff₃ e₁ e₂ e₃ -> f ∈ₑ e₁ ⊎ f ∈ₑ e₂
noEditMadeUp (here f) (merge (Id₁ g .f) d) = inj₂ (here f)
noEditMadeUp (here f) (merge (Id₂ .f g) d) = inj₁ (here f)
noEditMadeUp (here f) (merge (Idem .f) d) = inj₁ (here f)
noEditMadeUp (there g p) (merge m d) 
  = S.map (there _) (there _) (noEditMadeUp p d)
noEditMadeUp (thereᶜ c p) (conflict u d) 
  = S.map (there _) (there _) (noEditMadeUp p d)
\end{minted}

	The last safety property states that a successful \texttt{Merged₃}
	produces an edit script, whose output type is a subset of the output
	types of the input scripts.
	
	The following data type defines precisely such relation:

\begin{minted}{agda}
data _⊆_,_ : List Set -> List Set -> List Set -> Set where
  stop : [] ⊆ [] , []
  cons₁ : xs ⊆ ys , zs -> y ∷ xs ⊆ y ∷ ys , zs
  cons₂ : xs ⊆ ys , zs -> z ∷ xs ⊆ ys , z ∷ zs
  cons₁₂ : xs ⊆ ys , zs -> x ∷ xs ⊆ x ∷ ys , x ∷ zs
  drop₁ : xs ⊆ ys , zs -> xs ⊆ y ∷ ys , zs
  drop₂ : xs ⊆ ys , zs -> xs ⊆ ys , z ∷ zs
\end{minted}

	The type \texttt{xs ⊆ ys , zs} denotes that the list \texttt{xs} is a subset
	of the union of \texttt{ys} and \texttt{zs}.
	This is obvious in the basic constructor \texttt{stop}, when all
	the lists are empty.
	The invariant maintained by the \texttt{cons} constructors is that, for any
	three lists \texttt{xs}, \texttt{ys} and \texttt{zs} that satisfy this property,
	 whenever an element is added to \texttt{xs} it must be added also 
	to either \texttt{ys} by \texttt{cons₁}, or  to \texttt{zs} by \texttt{cons₂},
	or both by \texttt{cons₁₂}.
	Any element can be freely inserted in \texttt{ys} or \texttt{zs} with 
	\texttt{drop₁} and \texttt{drop₂}.
	
	The edits stored in a script are applied to the the source and 
	target objects, traversing their nodes in a depth-first order.
	The function \texttt{typesOf} collects in a list 
	the types of	the internal nodes in the same order.
	
\begin{minted}{agda}
typesOf : DList xs -> List Set
typesOf [] = []
typesOf (Node {a = a} α ts₁ ∷ ts₂) = a ∷ typesOf ts₁ ++ typesOf ts₂
\end{minted}

	The lemma theorem \texttt{mixOf} asserts that, upon a successful merge, 
	the types of the target object of the merged script
	is a subset of the types of the target objects of the two input edits.

\begin{minted}{agda}	
mixOf : Merged₃ e₁ e₂ e₃ -> typesOf ⟦ e₃ ⟧ ⊆ typesOf ⟦ e₁ ⟧ , typesOf ⟦ e₂ ⟧
\end{minted}

	Section \ref{subsec:Merged3} explains that output list of \texttt{e₃}
	cannot be computed in advance from the indexes of \texttt{e₁} and 
	\texttt{e₂}, therefore in the definition of \texttt{Merged₃} it is
	existentially quantified. This result gives a more precise statement 
	finding a relation between the output types of the three edit scripts.
	Foster et al.\ proves a stronger property, namely that the synchronization
	preserves the schema of the originals revisions \cite{Pierce07}.
	That result cannot be proved in this context because the two indexes
	are not plain types, but are list of types, that are used in a stack-like
	fashion and are essential to enforce type-safety.
	
%mixOf nil = stop
%mixOf (cons (Id₁ Nop Nop) p) = mixOf p
%mixOf (cons {e₂ = e₂} {e₃} (Id₁ Nop (Ins α)) p) rewrite
%  typesOf⟦ e₂ ⟧ | typesOf⟦ e₃ ⟧ = cons₂ (mixOf p)
%mixOf (cons {e₁ = e₁} (Id₁ (Upd α .α) (Del .α)) p) rewrite
%  typesOf⟦ e₁ ⟧ = drop₁ (mixOf p)
%mixOf (cons {e₁ = e₁} {e₂} {e₃} (Id₁ (Upd α .α) (Upd .α β)) p) rewrite
%  typesOf⟦ e₁ ⟧ | typesOf⟦ e₂ ⟧ | typesOf⟦ e₃ ⟧ = cons₁₂ (mixOf p)
%mixOf (cons (Id₂ Nop Nop) p) = mixOf p
%mixOf (cons {e₂ = e₂} (Id₂ (Del α) (Upd .α .α)) p) rewrite
%  typesOf⟦ e₂ ⟧ = drop₂ (mixOf p)
%mixOf (cons {e₁ = e₁} {e₃ = e₃} (Id₂ (Ins α) Nop) p) rewrite
%  typesOf⟦ e₁ ⟧ | typesOf⟦ e₃ ⟧ = cons₁ (mixOf p)
%mixOf (cons {e₁ = e₁} {e₂} {e₃} (Id₂ (Upd α β) (Upd .α .α)) p) rewrite
%  typesOf⟦ e₁ ⟧ | typesOf⟦ e₂ ⟧ | typesOf⟦ e₃ ⟧ = cons₁₂ (mixOf p)
%mixOf (cons (Idem Nop) p) = mixOf p
%mixOf (cons (Idem (Del α)) p) = mixOf p
%mixOf (cons {e₁ = e₁} {e₂} {e₃} (Idem (Ins α)) p) rewrite 
%  typesOf⟦ e₁ ⟧ | typesOf⟦ e₂ ⟧ | typesOf⟦ e₃ ⟧ = cons₁₂ (mixOf p)
%mixOf (cons {e₁ = e₁} {e₂} {e₃} (Idem (Upd α β)) p) rewrite 
%  typesOf⟦ e₁ ⟧ | typesOf⟦ e₂ ⟧ | typesOf⟦ e₃ ⟧ = cons₁₂ (mixOf p)
%\end{minted}
%
%	The base case is trivial.
%	In the recursive cases, the constructors \texttt{drop₁} and \texttt{drop₂} 
%	apply when respectively the first and the second edit are delete, and the
%	other is just a copy. The merged edit is delete and \texttt{drop} removes
%	the types of the elements merely copied.
%	The constructors \texttt{cons₁} and \texttt{cons₂} apply respectively
%	when the first and the second edit are either insert or update and the other
%	is just copy or a no-operation.
%	The constructor \texttt{cons₁₂} is used when both the edits agree on the
%	same insert or update operation. In the remaining cases (\texttt{Nop} and 
%	\texttt{Nop}, \texttt{Del} and \texttt{Del}) no constructor is needed, because
%	they do not affect \texttt{⟦\_⟧}.
%	\todo{Is this explanation useful?}
%	
%	Some simple manipulations, in the form of goal rewriting, are used:
%\begin{minted}{agda}
%typesOf⟦_⟧ : (e : ES xs (ys ++ zs)) -> let ds₁ , ds₂ = dsplit ⟦ e ⟧ in 
%               typesOf ds₁ ++ typesOf ds₂ ≡ typesOf ⟦ e ⟧
%\end{minted}
%	The proof is straightforward and relies on distributivity of \texttt{typesOf} over \texttt{+++} and associativity of \texttt{++}.

	\subsection{Maximality}
	\label{subsec:Maximality}
	Another important property discussed in this section is maximality 
	\cite{Pierce07}, which guarantees that all the \emph{changes} from both
	the scripts are included in the merged script in a \texttt{Diff₃} run.
		
	The type \texttt{Maximal e₁ e₂ e₃} asserts that the script \texttt{e₃} includes
	all the changing edits from \texttt{e₁} and \texttt{e₂}, thus they
	form a maximal triplet.
	
\begin{minted}{agda}
data Maximal : ES xs ys -> ES xs zs -> ES₃ xs -> Set where
 Nil : Maximal [] [] []
 Id₁ : (f : v ~> v) (g : v ~> w) -> Maximal e₁ e₂ e₃ 
   -> Maximal (f ∷ e₁) (g ∷ e₂) (g ∷ e₃)
 Id₂ : (f : v ~> w) (g : v ~> v) -> Maximal e₁ e₂ e₃ 
   -> Maximal (f ∷ e₁) (g ∷ e₂) (f ∷ e₃)
 Idem : (f : u ~> v) -> Maximal e₁ e₂ e₃ -> Maximal (f ∷ e₁) (f ∷ e₂) (f ∷ e₃)
\end{minted}

	The constructor \texttt{Nil} is correct because all the three scripts
	are the same, thus they form a maximal triplet.
	The constructor \texttt{Idem} reasonably adds the same edit \texttt{f} 
	to each script \texttt{e₁}, \texttt{e₂} and \texttt{e₃}, that form a maximal 
	triplet, thus preserving it.
	The presence of the other two constructors is explained because 
	the merged script must retain the \emph{changes} from the 
	input scripts, in order to be maximal.
	It is then fine to ignore identity edits, since they do not perform any 
	change.
	
	The following theorem shows that a \texttt{Diff₃} run that triggers no
	conflict is maximal.
	
\begin{minted}{agda}
Diff₃-maximal : Diff₃ e₁ e₂ e₃ -> NoCnf e₃ -> Maximal e₁ e₂ e₃
Diff₃-maximal nil [] = Nil
Diff₃-maximal (merge (Id₁ f g) p) (.g ∷ q) = Id₁ f g (Diff₃-maximal p q)
Diff₃-maximal (merge (Id₂ f g) p) (.f ∷ q) = Id₂ f g (Diff₃-maximal p q)
Diff₃-maximal (merge (Idem f) p) (.f ∷ q) = Idem f (Diff₃-maximal p q)
\end{minted}
	
	The proof is straightforward, since the constructors \texttt{Id₁}, \texttt{Id₂} 
	and \texttt{Idem} of \texttt{Maximal e₁ e₂ e₃} correspond exactly to those
	of \texttt{f ⊔ g ↧ h}.
	In particular note that, after pattern matching on the latter, \texttt{h} gets
	always instantiated with either \texttt{f} or \texttt{g}.
		
	\subsection{Structural Invariants}
	\label{subsec:Embedding}
	The last property discussed in this section concerns the ordering of 
	the nodes. An edit script transforms lists of trees, traversing and processing 
	their nodes in depth-first order.
	It represents a mapping from the source to the target, in which 
	nodes of the source are embedded in nodes of the target.
	The property central to this section is that the 
	embedding preserves the depth-first ordering of the 
	source and target nodes.
	However nodes are not only mapped (updated) from the source to the 
	target, but they may also be inserted, or removed. 
	Therefore the embedding-preserving property has to be adjusted to
	take these transformations into account.
	
	This section is structured as follows. Firstly the depth-first ordering on trees
	is formally defined and a similar relation is defined over
	edit scripts. Secondly the equivalence
	between these relations is proved. Lastly the proof that the same 
	property holds for successful merges is presented.
	
	\paragraph{Depth-First ordering}
	A pre-order depth-first traversal consists of
	firstly visiting the current node, then traversing recursively its subtrees 	
	from the leftmost to the rightmost.
	The traversal induces an ordering on the nodes, so that those that
	are visited sooner come before those that are processed later.
	Since the edit scripts manipulate list of trees, instead of single trees,
	also the definitions about ordering relations will be adjusted accordingly.

	The type \texttt{ts ⊢ α ⊏ β} denotes that, in the list of trees \texttt{ts}, 
	the node \texttt{α} comes before the node \texttt{β}, according to the
	depth first traversal.
	
\begin{minted}{agda}
data _⊢_⊏_ : DList xs -> F as a -> F bs b -> Set where
  here : (α : F as a) -> β ∈ (ts₁ +++ ts₂) -> Node α ts₁ ∷ ts₂ ⊢ α ⊏ β
  there : ts₁ +++ ts₂ ⊢ α ⊏ β -> Node γ ts₁ ∷ ts₂ ⊢ α ⊏ β
\end{minted}

	The list is used as a stack of trees containing the nodes to be visited.
	In the base constructor \texttt{here}, the node \texttt{α} is pushed on the 
	stack and thus comes before any node \texttt{β}, that belongs to the
	stack of nodes yet to be processed.
	The recursive constructor \texttt{there} adds a node \texttt{γ} to a list of 
	trees, in which \texttt{α} already comes before \texttt{β}.
	Note that the top elements of the stack (\texttt{ts₁}) are popped 
	and combined to construct a new tree, rooted respectively 
	in \texttt{α} and \texttt{γ}, which is then pushed on the stack. 
	In this way it is possible to extend the stack node by node, 
	retaining type-safety. 
	
	\paragraph{Edits ordering}
	The next data type defines a similar relation for edit scripts.
	The type \texttt{e ⊢ₑ f ⊏ g} asserts that in the script \texttt{e}, the edit
	\texttt{f} precedes the edit \texttt{g}.
	
\begin{minted}{agda}
data _⊢ₑ_⊏_ : ES xs ys -> u ~> v -> w ~> z -> Set where
  here : (f : w ~> z) -> g ∈ₑ e -> f ∷ e ⊢ₑ f ⊏ g 
  there : (h : s ~> t) -> e ⊢ₑ f ⊏ g -> h ∷ e ⊢ₑ f ⊏ g 
\end{minted}

	The following lemma shows that the order of two edits 
	is reflected in the source trees in the order of their source nodes.
\begin{minted}{agda}
⟪⟫-⊏ : (f : ⟨ α ⟩ ~> v) (g : ⟨ β ⟩ ~> w) -> e ⊢ₑ f ⊏ g -> ⟪ e ⟫ ⊢ α ⊏ β
\end{minted}
	Note that the type of the two edits guarantees that they have a source node.
	The proof is by induction over \texttt{e ⊢ₑ f ⊏ g}.

%⟪⟫-⊏ (Del α) g (here .(Del α) o) = here α (∈-dsplit _ (∈-⟪⟫ o))
%⟪⟫-⊏ (Upd α β) g (here .(Upd α β) o) = here α (∈-dsplit _ (∈-⟪⟫ o))
%⟪⟫-⊏ f g (there (Ins _) p) = ⟪⟫-⊏ f g p
%⟪⟫-⊏ f g (there {e = e} (Del _) p) = there (⟪⟫-lemma e (⟪⟫-⊏ f g p))
%⟪⟫-⊏ f g (there {e = e} (Upd _ _) p) = there (⟪⟫-lemma e (⟪⟫-⊏ f g p))
%⟪⟫-⊏ f g (there Nop p) = ⟪⟫-⊏ f g p
%	 and employs
%	the safety lemma \texttt{∈-⟪⟫} discussed in \ref{subsec:Safety} and 
%	some auxiliary functions:
%\todo{rename \texttt{⟪⟫-lemma} to \texttt{⟪⟫-dsplit}}
%\begin{minted}{agda}
%⟪⟫-lemma : (e : ES (xs ++ ys) zs) -> let ds₁ , ds₂ = dsplit ⟪ e ⟫ in 
%              ⟪ e ⟫ ⊢ α ⊏ β -> ds₁ +++ ds₂ ⊢ α ⊏ β
%
%∈-dsplit : (α : F as a) -> let ds₁ , ds₂ = dsplit ds in 
%            α ∈ ds -> α ∈ ds₁ +++ ds₂
%\end{minted}
%	Note that the only edits with type \texttt{⟨ α ⟩ \textasciitilde> v} are \texttt{Del α}
%	and \texttt{Upd α β}.
	
	A symmetric result is proved for \texttt{⟦\_⟧}:
\begin{minted}{agda}
⟦⟧-⊏ : (f : v ~> ⟨ α ⟩) (g : w ~> ⟨ β ⟩) -> e ⊢ₑ f ⊏ g -> ⟦ e ⟧ ⊢ α ⊏ β
\end{minted}
%⟦⟧-⊏ (Ins α) g (here .(Ins α) o) = here α (∈-dsplit _ (∈-⟦⟧ o))
%⟦⟧-⊏ (Upd α β) g (here .(Upd α β) o) = here β (∈-dsplit _ (∈-⟦⟧ o))
%⟦⟧-⊏ f g (there {e = e} (Ins α) p) = there (⟦⟧-lemma e (⟦⟧-⊏ f g p))
%⟦⟧-⊏ f g (there (Del α) p) = ⟦⟧-⊏ f g p
%⟦⟧-⊏ f g (there {e = e} (Upd α β) p) = there (⟦⟧-lemma e (⟦⟧-⊏ f g p))
%⟦⟧-⊏ f g (there Nop p) = ⟦⟧-⊏ f g p
	
	The converse lemma cannot be defined so easily.
	It would have the signature:
\begin{minted}{agda}
⊏-⟪⟫ : ⟪ e ⟫ ⊢ α ⊏ β -> ∃ λ (f : ⟨ α ⟩ ~> v) (g : ⟨ β ⟩ ~> w) -> e ⊢ₑ f ⊏ g 
\end{minted}
	
	The problem is that it is not possible to pattern match on 
	\texttt{⟪ e ⟫ ⊢ α ⊏ β} because of the function application \texttt{⟪ e ⟫}
	in its type.
	The \texttt{Diff} data type can remedy, abstracting over that.
	Furthermore the explicit existential quantification is avoided introducing
	two auxiliary data types.
	 
\begin{minted}{agda}
data _⊢ˢ_⊏_ (e : ES xs ys) (α : F as a) (β : F bs b) : Set where
  source-⊏ : {f : ⟨ α ⟩ ~> v} {g : ⟨ β ⟩ ~> w} -> e ⊢ₑ f ⊏ g -> e ⊢ˢ α ⊏ β 

data _⊢ᵗ_⊏_ (e : ES xs ys) (α : F as a) (β : F bs b) : Set where
  target-⊏ :  {f : v ~> ⟨ α ⟩} {g : w ~> ⟨ β ⟩} -> e ⊢ₑ f ⊏ g -> e ⊢ᵗ α ⊏ β
\end{minted}

	The type \texttt{e ⊢ˢ α ⊏ β} asserts that in \texttt{e} there are two
	edits \texttt{f} and \texttt{g}, whose \emph{source} nodes are respectively 
	\texttt{α} 	and \texttt{β}, such that \texttt{f} precedes \texttt{g} in \texttt{e}.
	Similarly the type \texttt{e ⊢ᵗ α ⊏ β} asserts that in \texttt{e} there are two
	edits \texttt{f} and \texttt{g}, whose \emph{target} nodes are respectively 
	\texttt{α} 	and \texttt{β}, such that \texttt{f} precedes \texttt{g} in \texttt{e}.
	
	Note that both the new types are parametric over the edit script and the 
	two nodes. Indeed they simply wrap the \texttt{e ⊢ₑ f ⊏ g} and
	qualify the edits \texttt{f} and \texttt{g} with appropriate source and
	target values.
	
	The following two lemmas use the \texttt{Diff} data type to convert
	the first relation to the second.	
\begin{minted}{agda}
diff-⊏ˢ : Diff x y e -> x ⊢ α ⊏ β -> e ⊢ˢ α ⊏ β
diff-⊏ᵗ : Diff x y e -> y ⊢ α ⊏ β -> e ⊢ᵗ α ⊏ β
\end{minted}
	The proof is by induction on the \texttt{⊏} relation and
	\texttt{Diff}, which eventually proves the presence of \texttt{α} in \texttt{x} 
	and an associated edit in \texttt{e} (\texttt{Del} or \texttt{Upd} in the first
	lemma, \texttt{Ins} or \texttt{Upd} in the second).
	The safety properties discussed in \ref{subsec:Safety}, specifically 
	two variants of \texttt{noSourceErase} and \texttt{noTargetErase}),
	are used to show the presence of an appropriate edit involving \texttt{β}
	in the tail of the script.
	
	\paragraph{Order-preserving embedding}
	All the necessary pieces are now available to prove the final theorem,
	which states that the edit script data type preserves the depth-first order,
	in the source and target objects.

	The theorem is split in two, the first considering only the ordering 
	of the source object, and the second only the target.
	
	The first one states that, given an edit script \texttt{e}, 
	if in its source object a node \texttt{α} comes before
	some node \texttt{β}, then one of the following holds:
\begin{itemize}
	\item \texttt{α} is deleted in \texttt{e};
	\item \texttt{β} is deleted in \texttt{e};
	\item There are two nodes \texttt{γ} and \texttt{φ}, such that the node 
	\texttt{α} is 	mapped to \texttt{γ}, the node \texttt{β} is mapped to 
	\texttt{φ} in \texttt{e} and 
	in the target	object, the node \texttt{γ} comes before \texttt{φ}
\end{itemize}

	The type \texttt{e ↦ α ⊏ β} denotes that \texttt{e} is a (source) 
	order-preserving embedding:
\begin{minted}{agda}
data _↦_⊏_ (e : ES xs ys) (α : F as a) (β : F bs b) : Set where
 Del₁ : e ⊢ₑ ⟨ α ⟩ ~> ⊥ -> e ↦ α ⊏ β
 Del₂ : e ⊢ₑ ⟨ β ⟩ ~> ⊥ -> e ↦ α ⊏ β
 Map₂ : e ⊢ₑ ⟨ α ⟩ ~> ⟨ γ ⟩ -> e ⊢ₑ ⟨ β ⟩ ~> ⟨ φ ⟩ 
       -> ⟦ e ⟧ ⊢ γ ⊏ φ -> e ↦ α ⊏ β
\end{minted}

	The proof exploits a number of results previously discussed,
	therefore it is reported in full:

\begin{minted}{agda}
preserve-↦ : ⟪ e ⟫ ⊢ α ⊏ β -> e ↦ α ⊏ β
preserve-↦ {e = e} p with diff-⊏ˢ (mkDiff e) p
preserve-↦ p | source-⊏ {f = Del α} x = Del₁ (Del α (⊏ₑ-∈₁ x))
preserve-↦ p | source-⊏ {f = Upd _ _} {Del β} x = Del₂ (Del β (⊏ₑ-∈₂ x))
preserve-↦ p | source-⊏ {f = Upd α γ} {Upd β φ} x 
  = Map₂ (Upd α γ (⊏ₑ-∈₁ x)) (Upd β φ (⊏ₑ-∈₂ x)) (⟦⟧-⊏ (Upd α γ) (Upd β φ) x)
\end{minted}

	By the lemma \texttt{diff-⊏ˢ}, it follows that \texttt{e ⊢ˢ α ⊏ β},
	i.e.\ there are two edits \texttt{f} and \texttt{g} with source nodes 
	respectively \texttt{α} and \texttt{β}.
	The definition of \texttt{e ⊢ˢ α ⊏ β} restricts the type of 
	\texttt{f} and \texttt{g} to be \texttt{⟨ α ⟩ \textasciitilde> v} and \texttt{⟨ β ⟩ \textasciitilde> w}, 
	therefore the only possible edits with these types are \texttt{Del α},
	\texttt{Del β}, \texttt{Upd α γ} and \texttt{Upd β φ} for some
	nodes \texttt{γ} and \texttt{φ}, which are
	correctly reported by pattern matching.
	When either of them is a delete, one of the \texttt{Del} constructors applies,
	when both are updates the \texttt{Map₂} is used.
	The following lemmas are used to convert the relation \texttt{e ⊢ₑ f ⊏ g}
	in \texttt{f ∈ₑ e} and \texttt{g ∈ₑ e}.
	The proofs are by straightforward induction and thus omitted.
	
\begin{minted}{agda}
⊏ₑ-∈₁ : e ⊢ₑ f ⊏ g -> f ∈ₑ e
⊏ₑ-∈₂ : e ⊢ₑ f ⊏ g -> g ∈ₑ e
\end{minted}

	The second theorem is symmetrical to the first and thus it will be briefly 
	sketched.
	It states that, given an edit script \texttt{e}, if in its
	target object a node \texttt{α} comes before
	some node \texttt{β}, then one of the following holds:
	\begin{itemize}
		\item \texttt{α} is inserted in \texttt{e};
		\item \texttt{β} is inserted in \texttt{e};
		\item There are two nodes \texttt{γ} and \texttt{φ}, such that the node 
		\texttt{γ} is mapped to \texttt{α}, the node \texttt{φ} is mapped to 
		\texttt{β} in 	\texttt{e} and in the source object, 
		the node \texttt{γ} comes before \texttt{φ}
	\end{itemize}

	The type \texttt{e ↦ α ⊏ β} denotes that \texttt{e} is a (target) 
	order-preserving embedding:

\begin{minted}{agda}
data _↤_⊏_ (e : ES xs ys) (α : F as a) (β : F bs b) : Set where
 Ins₁ : e ⊢ₑ ⊥ ~> ⟨ α ⟩ -> e ↤ α ⊏ β
 Ins₂ : e ⊢ₑ ⊥ ~> ⟨ β ⟩ -> e ↤ α ⊏ β
 Map₂ : e ⊢ₑ ⟨ γ ⟩ ~> ⟨ α ⟩ -> e ⊢ₑ ⟨ φ ⟩ ~> ⟨ β ⟩ 
       -> ⟪ e ⟫ ⊢ γ ⊏ φ -> e ↤ α ⊏ β
\end{minted}
         
	The proof follows the same structure as \texttt{preserve-↦} 
	and will not be discussed any further.
\begin{minted}{agda}
preserve-↤ :  ⟦ e ⟧ ⊢ α ⊏ β -> e ↤ α ⊏ β 
\end{minted}
%preserve-↤ {e = e} p with diff-⊏ᵗ (mkDiff e) p
%preserve-↤ p | target-⊏ {f = Ins α} x = Ins₁ (Ins α (⊏ₑ-∈₁ x))
%preserve-↤ p | target-⊏ {f = Upd _ _} {Ins β} x = Ins₂ (Ins β (⊏ₑ-∈₂ x))
%preserve-↤ p | target-⊏ {f = Upd α γ} {Upd β φ} x 
%  = Map₂ (Upd α γ (⊏ₑ-∈₁ x)) (Upd β φ (⊏ₑ-∈₂ x)) (⟪⟫-⊏ (Upd α γ) (Upd β φ) x) 
	
	\paragraph{Corollary}
	The next corollaries assert that \texttt{Diff} is order-preserving.
 	They rely on the fact that \texttt{Diff x y e} is equivalent to
	\texttt{Diff ⟦ e ⟧ ⟪ e ⟫ e}.

\begin{minted}{agda}
Diff↦ : Diff x y e -> x ⊢ α ⊏ β -> e ↦ α ⊏ β
Diff↦ d p rewrite mkDiff⟪ d ⟫ = preserve-↦ p

Diff↤ : Diff x y e -> y ⊢ α ⊏ β -> e ↤ α ⊏ β
Diff↤ d p rewrite mkDiff⟦ d ⟧ = preserve-↤ p
\end{minted}

	\paragraph{Merged$_3$}
	Also successful merges retain the order-preserving property, i.e.\
	the order of the edits in the input scripts is preserved.
	In the specifications of \texttt{Diff₃}, the input edits are not rearranged, 
	but rather merged pointwise, keeping the original order in the new script,
	hence intuitively this property ought to hold.
	Nevertheless identity edits might be dropped from the merged script, 
	according to the semantics of \texttt{f ⊔ g ↧ h},
	consequently the theorem states that successful merges are 
	order-preserving with respect to \emph{change edits}.
	Note also that successful merges do not trigger any conflict, which
	would also break this property.
	
\begin{minted}{agda}
diff3-⊏₁ : Change f -> Change g -> e₁ ⊢ₑ f ⊏ g -> Merged₃ e₁ e₂ e₃ -> e₃ ⊢ₑ f ⊏ g
diff3-⊏₁ (IsChange v≠w) c₂ (here f o) (cons (Id₁ .f g) q) = ⊥-elim (v≠w refl)
diff3-⊏₁ c₁ c₂ (here f x) (cons (Id₂ .f g) q) 
  = here f (noBackOutChangesMerged₁ c₂ q x)
diff3-⊏₁ c₁ c₂ (here f x) (cons (Idem .f) q) 
  = here f (noBackOutChangesMerged₁ c₂ q x)
diff3-⊏₁ c₁ c₂ (there a p) (cons m q) = there _ (diff3-⊏₁ c₁ c₂ p q)
\end{minted}
  
	The proof of this theorem is by induction on \texttt{e₁ ⊢ₑ f ⊏ g}.
	The need for the \texttt{Change f} is obvious in the first case, where
	the merge proof reveals that \texttt{f} is identity and therefore it would be 
	discarded	in favour of \texttt{g} in the merged script.
	This case is ruled out by contradiction, thanks to this additional piece
	of information.
	The auxiliary lemma \texttt{noBackOutChangesMerged₁} is a corollary 
	of \texttt{noBackOutChanges₁} discussed in \ref{par:diff3-safety}.
		
\begin{minted}{agda}
noBackOutChangesMerged₁ : Change f -> Merged₃ e₁ e₂ e₃ -> f ∈ₑ e₁ -> f ∈ₑ e₃
\end{minted}
	
	Obviously \texttt{Merged₃ e₁ e₂ e₃} is a subset of \texttt{Diff₃ e₁ e₂ e₃}, 
	because it restricts \texttt{e₃} to be well-typed and conflictless, therefore 
	the corollary follows directly from this inclusion.
	
	Of course \texttt{Merged₃ e₁ e₂ e₃} is order-preserving also with respect
	to the edits of the second script, since it is symmetric.
	
\begin{minted}{agda}
diff3-⊏₂ : Change f -> Change g -> e₂ ⊢ₑ f ⊏ g -> Merged₃ e₁ e₂ e₃ -> e₃ ⊢ₑ f ⊏ g
diff3-⊏₂ c₁ c₂ p d = diff3-⊏₁ c₁ c₂ p (Merged₃-sym d)
\end{minted}
	
	The lemma \texttt{Merged₃-sym} swaps the two input scripts.
\begin{minted}{agda}
Merged₃-sym : Merged₃ e₁ e₂ e₃ -> Merged₃ e₂ e₁ e₃
Merged₃-sym nil = nil
Merged₃-sym (cons m d) = cons (↧-sym m) (Merged₃-sym d)
\end{minted}	
	
	The final corollary asserts that \texttt{Merged₃ e₁ e₂ e₃} is 
	order-preserving also with respect to 	the original source object.

\begin{minted}{agda}
Merged₃↦ : Diff x y e₁ -> Diff x z e₂ -> Merged₃ e₁ e₂ e₃ -> x ⊢ α ⊏ β -> e₃ ↦ α ⊏ β
Merged₃↦ {e₃ = e₃} d₁ d₂ d₃ p rewrite
  trans mkDiff⟪ d₁ ⟫ Merged₃⟪ d₃ ⟫ = Diff↦ (mkDiff e₃) p
\end{minted}

	The corollary holds because \texttt{mkDiff⟪ d₁ ⟫} implies that
	\texttt{x ≡ ⟪ e₁ ⟫} and from \texttt{Merged₃⟪ d₃ ⟫} it follows
	that \texttt{⟪ e₁ ⟫ ≡ ⟪ e₃ ⟫}.
	
\section{Conclusion}
The main contributions of this thesis are:
\begin{itemize}
	\item A data type generic \texttt{diff} algorithm for structured
			data that employs insert, delete, update edits and \emph{global} 
			alignment.
	\item A state-based, three-way, persistent \texttt{diff3} algorithm.
	\item A formal model to reason about diffing 
				and merging.
\end{itemize}

In addition a number of results have been mechanically verified using the model, with the Agda proof assistant.
\begin{itemize}
	\item The necessary and sufficient conditions for the presence of conflicts 
	have been pinpointed.
	\item Some \textbf{safety properties}, which ensure the basic correctness 
	of the algorithms, have been established and proved.
	\item The \texttt{diff3} algorithm is \textbf{maximal}.
	\item The algorithms preserve some well-defined \textbf{structural invariants}, such as order-preservation.
\end{itemize}

	\subsection{Related Work}
	\label{subsec:RelatedWork}
	The great number of publications shows that there is an increased 
	interest in the topics of change detection and merge.
	There are several tools that target structured data, with a particular
	focus on the XML format, such as 
	LaDiff \cite{Chawathe96}, MH-Diff  \cite{Chawathe97} and 3DM  
	\cite{Lind01, Lind04, Lind05}.
	Peters gives a comprehensive survey of them and others	
	\cite{PetersSurvey}.
	Synchronizers represent another closely related field.
	Relevant examples include Unison, a file synchronizer \cite{Pierce98, 
	UnisonSpec}; Harmony, a synchronizer for 
	heterogeneous data	\cite{HarmonyOverview,Pierce07} by Pierce et al.\ and
	an algebra for file synchronization \cite{Ramsey01}.
	Lastly there are many mergers tailored for software artifacts
	\cite{Westfechtel91, Apel11}.
	Mens gives a comprehensive survey of this field\cite{Mens02}.

	\paragraph{Ordered and Unordered}
	The merger discussed in this thesis is different from all of these, because,
	contrary to XML and file-systems, the tree-structured objects handled
	are actually data types, therefore they are \emph{strongly typed} entities.
	Being typed, the trees are inherently \emph{ordered}, while XML trees
	could also be unordered. 
	However there is a connection between types and schemas, 
	which Foster et al.\ consider essential for synchronization \cite{Pierce07}.
	Indeed their synchronizer preserves structural 
	invariants,  exploiting schemas to identify specific conflicts, 
	named \emph{schema domain conflicts}. Similarly in this work a
	merge is considered \emph{successful} only if it is well-typed 
	\ref{subsec:Merged3}. 
	Chawathe et al.\ assume that nodes have unique 
	identifiers \cite{Chawathe96}, 
	which greatly simplifies the change detection phase.
	However this assumption is too simplistic: data format do not usually mark
	their content and even XML trees may or may not have  
	identifiers in their nodes. The algorithms discussed in this thesis do
	not rely on unique identifiers, even though they could be adapted 
	straightforwardly to take advantage of them.
	
	\paragraph{Alignment and Data Structures}
	The alignment strategy used to match parts in two versions plays
	a central role in the quality of merges.

	Khanna et al.\ explain that GNU diff3 aligns lines
	computing \emph{stable} and \emph{unstable} \emph{chunks} from the 
	longest common subsequences between the base and the two new versions, 
	obtained by the \texttt{diff} subroutine \cite{PierceDiff3}.
	Overlapping equal lines are matched and fused in stable chunks, leaving 
	possibly conflicting chunks between them.
	This technique works well in practice because (in software artifacts) lines
	are mostly unique and it is restricted to a simple, flat, linear structure.
	Nevertheless this approach would most likely give poor results for trees. 
	Firstly chunks intuitively align flat data like lists,
	but they would oddly flatten vertical, structured data like trees.
	Secondly the implicit assumption that basic values are mostly
	unique might not hold for certain data formats and therefore it would 
	misalign their content.
	Therefore the diff discussed in this thesis strives to match single nodes,
	computing an embedding of the original tree into the other; furthermore
	it respects their structured nature preserving the relative order of the 
	nodes, in 	the depth first order traversal, as shown in section 
	\ref{subsec:Embedding}.
	This is achieved by generalizing the copy edit to update and retaining the
	intuitive three-way merge technique for aligned edits.
	The merger presented in this thesis employs a \emph{global} strategy
	that produces an optimal alignment, minimizing an appropriate cost model.
	Conversely Foster et al.\ choose a \emph{local} strategy,
	that associates subtrees by name \cite{Pierce07}.
	Chawathe and Molina reduce the change detection
	problem to a problem of computing a minimum-cost edge cover of 
	a bipartite graph \cite{Chawathe96}. 
	They remark that for structured data this problem
	is NP-hard, therefore they develop an heuristic that consists
	in pruning the graph induced by two trees following a set of pruning
	rules and then 	further discard edges to find a \emph{minimal} edge cover.
	From the edge cover an edit script can be mechanically derived, however
	they do not discuss changes merge in their work.
		
	\paragraph{Data Structures}
	Data structures are implemented as algebraic data types, that 
	have always the form of structured ordered trees
	regardless of the fact that may represent unordered collections such as 	
	sets and records. Since the alignment strategy is strongly influenced by 
	the actual shape of the trees, these class of objects will be 
	badly matched and will be poorly merged, probably raising 
	unnecessary conflicts.
	Foster's synchronizer handles sets and records 
	correctly, but just because their algorithm is 
	schema-driven and internally handles schema keys as sets \cite{Pierce07}.
	On the other hand it performs poorly for lists, 
	because it naively aligns lists by \emph{absolute} positions, due to the 
	local alignment strategy used. 
	For example merging $o$ \texttt{= [Liz; Jo]}, $a$ \texttt{= [Jo]} and $b$ 
	\texttt{= [Liz; Joanna]} surprisingly produces \texttt{[Jo; Joanna]}, instead
	of \texttt{[Joanna]}, 
	which is correctly reported by the merger presented here.
	
	\paragraph{Edit operations}
	The set of edits considered in the change detection phase plays
	a fundamental role when merging changes.
	The edits generated by GNU diff include only insert, delete and copy, 
	which in this thesis has been broadened to update as explained previously.
	Lindholm includes also the edit move in his synchronizer \cite{Lind04}, 
	like Chawathe \cite{Chawathe96, Chawathe97}, 
	who additionally introduces also the glue edit that fuses two trees.
	Lindholm however copy consists of copying multiple nodes \cite{Lind04}.
	Since node sharing is not explicit this operation could easily produce 
	surprising results, because it could match unrelated nodes. In XML
	this is mitigated since large sections of text are likely unique, but
	in our context it is in general an invalid assumption.
	Move is quite a controversial edit.
	It can be expressed in the model presented in this thesis by delete 
	and insert, just like in Ramsey's \cite{Ramsey01}, however this sequence 
	of edits might easily clash with possible updates in the other version,
	raising unnecessary conflicts.
	Crucially tree rearrangements	might not be recognized as a natural
	edit in certain data formats, but they could for others. 
	For example in a table filled with numbers it would look odd to describe
	changes in few numbers using moves, but it is perfectly reasonable
	to do it for rows shuffling. 
	Lindholm takes into account the \emph{context}, made of a node's parent, 
	predecessor	and successor, in order to improve the precision
	in the change detection phase with respect to the move edit \cite{Lind04},
	however he also remarks that there are few exceptions.
	It is challenging to craft an alignment strategy that includes the move edit,
	while keeping its semantics concise and clear, especially in presence
	of multiple weight parameters, such as in the cost model 
	defined by Chawathe \cite{Chawathe97}.
	Furthermore mode edits would weaken the guarantees about the
	structural invariants described in \ref{subsec:Embedding}.
	Ramsey et al.\ remark that the \emph{move} operation 
	complicate reasoning, but they suggest to expose it to the user and 
	translate it using delete and insert for reasons of performance, retention of 
	metadata 	and usability \cite{Ramsey01}.
	It is however questionable whether this translation preserves the original 
	meaning.	
	
	\paragraph{Formal Model}
	The proliferation of commercial and research file synchronizers and
	mergers have yielded the need for a formal study of their semantics.
	Unison \cite{UnisonSpec} is an example of a file synchronizer 
	automacally derived	 from a formal model \cite{Pierce98}.
	Similarly Harmony is a schema-based
	synchronization framework \cite{HarmonyOverview}, whose formal
	properties have been studied extensively \cite{Pierce07} and have
	inspired the analysis conducted in section \ref{sec:FormalProp}.
	Ramsey and Csirmaz proposes an algebraic approach to 
	file synchronization \cite{Ramsey01}. 
	Differently from this thesis, Unison \cite{Pierce98} and Harmony 
	\cite{Pierce07}, their model is operation-based, rather than state-based,
	which enables an automatic conflict resolution phase named 
	\emph{reconcilation}.
	Nevertheless the sequence of operations performed at each replica
	is computed in the update detection phase at each replica 
	comparing the current version with the archive, i.e.\ the last synchronized 
	version. 
	It is worth pointing out that this phase is greatly simplified by the presence
	of metadata in filesystems, which helps to disambiguate during 
	the alignment phase and facilitates the change detection phase.
	They propose a large proof system 	for a simple filesystem algebra, that
	is proved to be sound and complete for it.
	The model is based on a relation between sequences
	of commands that ensures that a sequence safely approximates another
	and conflictless synchronization is possible if there is a sequence
	at least as good as both.
	Even though the algebra is intuitive, the proof system is quite large and
	far from concise, to the point that it requires automatic techniques to
	prove it sound.
	They claim that reasoning with algebraic laws is more convenient that 
	reasoning directly with the mathematical formulation of the filesystem, 
	however it looks like this approach is unlikely to scale, since 
	a simple model made of five operations requires about fifty laws to
	be equivalently described algebraically.
	The combinatorical explosion is due to the fact that laws relate
	the effect of sequencing two operations. 	
	Ramsey's algebraic approach is interesting, but
	it relies too much in a clear detection of the operations performed, which 
	for structured data is much more blurry. 
	The 3DM tool devised by Lindholm does not include a 
	mechanically verified model and moreover the general merge rules 
	have been derived analyzing the expected result of use cases \cite{Lind04}.
	His change model is based on \emph{content} and \emph{structural 
	change}. The changes in each version are combined into a change set
	and can be merged only if the set is \emph{consistent}, i.e. 
	unambiguously determine at most one parent, predecessor and successor
	for each node.
	Conflicts are divided in core conflicts and optional conflicts and are 
	overall consistent with those listed in \ref{subsec:Merge}, except
	for the delete/edit conflict, which is optional, whereas in this
	thesis is not. It is not explained under which circumstances these
	changes could be considered compatible.
	The lack of a formal model raises some doubts about the properties
	claimed for the merge.
	First of all the merge is considered symmetric, but later
	it is admitted that appends of nodes originated from different
	trees may be accepted in either order. This kind of implementation
	details are actually relevant from the user point of view and have so 
	far fostered the need for formal, unambiguous models. In this thesis
	inserts compete for matching positions and may trigger conflicts
	if incompatible.
	Secondly the fourth merge rule explicitly requires that changes in either
	versions to be included in the merged tree, however the fact
	that updates in deleted trees are optionally considered conflicts contradicts
	this rule and weaken the property about preservation of edits.
	
	% Structural invariants	
	
	% Reliable with respect to edits with source the archive tree (module good 
	% matching, which is assumed because of the global alignment)
	% More tentative the alignment for inserts: at the moment it relies on
	% the same traversal. Probably context information could be exploited
	% to better align inserts.

	
% Not sure ...	
%	Synchronization is slightly different from merging, as intended in this
%	thesis and in the XML works mentioned previously.
%	Synchronizers can be classified as \emph{persistent} or \emph{convergent}, 
%	depending on the strategy used to synchronize independent replicas.
%	Convergency requires that the two replicas must be equal, after
%	synchronization
%	Three-way mergers are given two current versions of an object and an 
%	archive version and try to combine the changes that occur from the 
%	common version to the other two, to produce a single object that
%	merges both. Synchronizers instead work with independent replicas, which
%	are updated propagating the non-conflicting changes	
	
	
	\subsection{Future Work}	
	This thesis raises several research questions, which ought to be 
	addressed in future works.
	
	\paragraph{Comparison with other tools}
	Even though GNU \texttt{diff3} is currently the most widespread merger 
	used for software artifacts, only recently the algorithm has been put on a 
	formal footing by Khanna et al.\ in \cite{PierceDiff3}.
	It would be interesting to compare it to the algorithm proposed here
	and particularly analyze the connection between the conflicts detected
	by each. It is natural to wonder whether there is any relation between
	the class of conflicts that they target. 
	
	Furthermore since there is an increased interest in these topics, as 
	witnessed by the great number of publications, a general framework
	to compare properly different tools with similar characteristics 
	should be devised. Specifically it should be possible 
	to determine whether they have the same expressive power and
	conflict detection capabilities.
	
	\paragraph{Ancestor successor order}		
	Section \ref{subsec:Embedding} shows that the depth-first order
	of the nodes in the source object are preserved in the target object,
	and also in the merged object, in case of a successful merge.
	These properties give to the users some indication about the relative
	position of the nodes in the merged object, however an even stronger
	property could be enforced. In fact since the data diffed and merged is 
	structured as trees, it would be natural to preserve also the 
	ancestor-successor relationship between nodes.
	From the user point of view, this relation is certainly clearer and likely 
	more meaningful than the previous one and moreover it fits nicely
	with the idea of preserving the structure of the objects.
	Note that this property is stronger and implies the structural invariant
	discussed in \ref{subsec:Embedding}.
	The edit script data type compares source and target tree, flattening
	them according to the depth-first order, therefore erasing any
	vertical relation between their nodes. 
	Consequently the edit script data type is responsible
	for enforcing the relations between nodes, hence its definition 
	needs to be	adjusted to retain the ancestor-successor relationship
	between nodes. 
	
	\paragraph{Hook for data structures}
	As discussed previously tree matching, diffing and merging is
	inappropriate for algebraic data types that represent unordered data 
	structures. The model presented here could be easily adjusted
	to allow the definition of specific diffing and merging semantics 
	for certain class of data types.
	
	\paragraph{Move edit and Contexts}	
	It would be interesting to optionally extend the model to include move
	edits, since rearrangements of nodes is common for certain formats
	such as XML and HTML. As Ramsey remarks, this would 
	likely complicate the formal model and its properties, but it 
	would certainly improve the user experience and the merging
	capabilities.
	The idea of node \emph{contexts} described by Lindholm 
	\cite{Lind01} ought
	to be investigated further especially in presence of a move edit. 
	It particularly fits nicely in this setting, not only 
	because it corresponds to Huet's Zipper data structure \cite{Zipper} 
	and McBride's derivative \cite{Derivative}, but also because
	it allows to exploit the types of the parent, ancestor 
	and successor nodes to align data correctly, producing 
	well-typed trees.
	Contexts could also be effectively employed in the second part of the
	alignment phase, in which inserts are aligned with either other inserts,
	or purposely added no-operations. In fact this
	naive approach could have a negative impact, in presence of many inserts 
	because too simplistic. In particular contexts 
	could guide this stage, inserting nodes only in valid positions.
			
	% TODO remove when compiling the whole thesis	
%	\bibliographystyle{plain}
% 	\bibliography{svc}
		
\end{document}
