\documentclass[../Thesis.tex]{subfiles}

\begin{document}
\chapter{Haskell Implementation}
\label{chp:Haskell}
\todo{Remove tick from constructors in types}
This chapter presents the Haskell implementation of the \texttt{diff}
and \texttt{diff₃} algorithms discussed in \ref{chapter:FormalModel}.

	\subsection*{Motivation}
	Even though Agda's type system is sophisticated, it is still a research 
	prototype and its compiler is still rather immature and does not produce
	efficient code. Consequently a more mature programming language has 
	been chosen to provide a practical implementation of
	the algorithms studied in this thesis.
	Haskell, a general-purpose, strongly typed, purely functional 
	programming language \cite{Hudak07ahistory, Marlow_haskell2010} 
	has been used for this purpose.
	Even though full-fledged dependent types are not available, the 
	Glasgow Haskell Compiler (GHC) \cite{GHC}, the current state-of-the-art, 
	optimizing compiler for Haskell, provides several extensions to the type
	system, which allow to partially simulate dependently typed programming.
	The implementation discussed in this chapter 
	relies heavily on them, in particular on Generalized Algebraic Data Types 
	(GADT) \cite{JonWasWei04,PeytonJonesSUT,SchGADT} and Type Families
	\cite{ChakATC,ChakATS,SchrTCO,SchrTOT,Kiselyov09funwith}, and was
	developed using the latest stable release of GHC, version 7.8.3.
	The shortcomings of the implementation with respect
	to the formal model, developed instead in a dependently typed language, 
	will be pointed out.
	
	\section{Basics}
	This section presents the basic data types and type classes used 
	in the algorithms section.

	\subsection{Type Manipulation}

	\paragraph{Proxy}
	Programs that inspect and manipulate types need specific data types
	and functions, whose main role is to fix types and 
	ultimately drive type inference, rather than storing and computing values.
	For example the data type \texttt{Proxy a} is a poly-kinded proxy type that 
	has only one non-bottom value, namely \texttt{Proxy}, and it
	is usually used to specify types in signatures.
	
\begin{minted}	{haskell}
data Proxy t = Proxy
\end{minted}
	
	\paragraph{Type Equality}
	In the formal model a decidable type equality operator was assumed in
	the \texttt{diff} algorithm and extensively used to type check
	merged edit script. 
	Such an operator is provided by the library \texttt{Typable} \cite{SYB}:
\begin{minted}{haskell}
eqT :: (Typeable a, Typeable b) => Maybe (a :~: b)
\end{minted}

	The class \texttt{Typeable} includes the method \texttt{typeRep},
	that given a proxy type produce a unique type representation for
	it. The function \texttt{eqT} compares the type
	representations and if they are equals manufactures an equality proof, 
	using unsafe operations. The implementation is then safe under the 
	assumptions that the type representations generated are unique.
	Instances of the class \texttt{Typable} can be automatically generated for 
	any data type and, to further increase the safety of the library, manual
	instances of \texttt{Typeable} are rejected.
	Type representations include hash fingerprints which are generated
	accessing GHC internal representations of data.

	For convenience the following auxiliary function will be used 
	to compare types:
	
\begin{minted}{haskell}
tyEq :: (Typeable a, Typeable b) => Proxy a -> Proxy b -> Maybe (a :~: b)
tyEq _ _ = eqT
\end{minted}

	\subsection{Universe}
	\label{subsec:Universe} \todo{Better name?}
	The type class \texttt{Diff a} denotes that the type \texttt{a}
	can be diffed.
		
\begin{minted}{haskell}
class Typeable a => Diff a where
  type FamilyOf a :: [ * ] -> * -> *
  (=?=) :: F xs a -> F ys a -> Maybe (xs :~: ys)
  distance :: F xs a -> F ys a -> Double
  argsTy :: F xs a -> TList xs
  toDTree :: a -> DTree a
  fromDTree :: DTree a -> a
  string :: F xs a -> String
\end{minted}

	The associated type \texttt{FamilyOf a} is to be instantiated with the 
	concrete data type that represents the constructors of \texttt{a}.
	It corresponds to the postulated data type \texttt{F} of kind
	\texttt{List Set -> Set -> Set} assumed in the formal model in 
	\ref{subsec:DTree}.
	For ease of explanation and to keep the implementation consistent 
	with the formal model, the following type synonym is used:
\begin{minted}{haskell}
type F xs a = (FamilyOf a) xs a
\end{minted}
	A value of type \texttt{F as a} represents a concrete constructor
	of \texttt{a} that takes arguments of types determined 
	by \texttt{as}.
	The first method \texttt{=?=} tests for equality between nodes, analogously
	to the operator described in the formal model, except with a less 
	refined signature.
	The second method \texttt{distance} assigns a numeric distance
	between constructors of the same type. 
	It is expected to satisfy the metric axioms listed in \ref{par:Metric}.
	The method \texttt{argsTy} reifies the types of the arguments of a 
	constructor and are needed to type check merged edit scripts.
	The methods \texttt{toDTree} and \texttt{fromDTree} are used to convert
	raw data types to a well-typed generic tree representation
	and the other way around.
	Lastly the method \texttt{string} returns a string representation of a
	constructor and it is used exclusively to interact with the user.
		
	In addition the auxiliary function \texttt{decEq} tests whether
	two constructors belong to the same type.
	
\begin{minted}{haskell}
decEq :: (Diff a, Diff b) => F xs a -> F ys b -> Maybe (a :~: b)
decEq _ _ = tyEq Proxy Proxy
\end{minted}

	\subsection{Typed List}		
	\todo{Is it better to have just an introductive 	chapter about all these
	kinds of lists?}
	The algorithms manipulate several different kind of typed list,
	which are all small variation of the heterogeneous list \texttt{HList} 
	introduced in \ref{chapter:FormatRepresentation} \todo{Specific section 
	about HList}. This section defines them and explains their role.
	
	\paragraph{TList}
	The type \texttt{TList as} represents a list of types \texttt{as} each 
	of them belonging to the family \texttt{Typeable}.

\begin{minted}{haskell}
data TList as where
  TNil :: TList []
  TCons :: Typeable a => Proxy a -> TList as -> TList (a : as)
\end{minted}
	The presence of the proxy is to conveniently manipulate the type later on.
	
	An appropriate \texttt{TList} can be automatically built for lists of types 
	known at compile time, in a similar manner to what happens for
	\texttt{SList} with \texttt{KnownSList}, as described in \ref{?}.
	\todo{Specific section about SList.}
	
\begin{minted}{haskell}
class KnownTList as where
  tlist :: TList as
\end{minted}
	The only two generic instances are:
\begin{minted}{haskell}
instance KnownTList '[] where
  tlist = TNil

instance (Typeable a, KnownTList as) => KnownTList (a : as) where
  tlist = TCons Proxy tlist
\end{minted}

	This technique exploits the automatic instance resolution that happens
	while type-checking, to progressively build the desired \texttt{TList}.
	In the second instance the type checker infer the expected type 
	\texttt{Proxy a} for \texttt{Proxy} and the recursive call to \texttt{tlist} is 
	justified by the constraint  \texttt{KnownTList as} in the context. 
	The constraint \texttt{Typeable a} is instead required by
	the constructor \texttt{TCons}.
		
	It is also entirely straightforward to provide an instance for the 
	type	class \texttt{Reify}, which converts a \texttt{TList as} 
	into the corresponding singleton type 
	\texttt{SList as}, introduced in \ref{slist section}. 
	\todo{Add section specific to SList}

\begin{minted}{haskell}
instance Reify TList where
  toSList TNil = SNil
  toSList (TCons _ t) = SCons (toSList t)
\end{minted}
	
	\paragraph{DList}
	The type \texttt{DList as} represents a list of \texttt{DTree} of types
	determined by 	\texttt{as}. Their definition is entirely similar to
	the one given in the formal model, except that it requires
	an instance of \texttt{Diff} for each type contained.
	
\begin{minted}{haskell}
data DList xs where
  DNil :: DList []
  DCons :: Diff a => DTree a -> DList as -> DList (a : as)

data DTree a where
  Node :: F as a -> DList as -> DTree a
\end{minted}
	
	The data type \texttt{DTree a} is a type safe representation of
	an algebraic data type of type \texttt{a}, where the term
	of type \texttt{F as a} is a reifyed witness of a constructor 
	of \texttt{a}.
	
	\section{Diff}
	This section describes the implementation of the 
	\texttt{diff} algorithm presented in 	section \ref{subsec:Diff} 
	and the related data types. 
	
	\subsection{Edit Script}
	The edit script data type described in \ref{subsec:EditScript} consists in
	a well-typed list of edits of type \texttt{u \textasciitilde> v}, each of them
	encoding the change made with their source and target values.
	That definition is particularly elegant because it isolates the actual set of
	edits from the conditions required to stack them in a type-safe manner.
	They are embedded in the cons constructor signature and consist
	in expecting the input types of the edit to match the prefix of the
	type lists of the rest of the edit script.
	Remarkably these rules are the same regardless of the concrete edit 
	at hand, which makes it possible to separate the two data types.
	This modular representation is unfortunately not possible in the current
	version of GHC for two reasons. Firstly GADTs are unpromotable,  i.e. it is 
	not possible index a GADT by another GADT, which prevents the edit data 
	type	to be indexed by values.
	As Yorgey et. al explain in \cite{Yorgey12}, this feature would require kind 
	equality and kind coercions, which would  dramatically complicate type 
	equivalence.
	Secondly not even indexing edits directly by their input and output type lists
	would completely solve the issue:
	
\begin{minted}{haskell}
data Edit as bs cs ds where
  Ins :: F as a -> Edit [] [] as [ a ] 
  Del :: F as a -> Edit as [ a ] [] [] 
  Upd :: F as a -> F bs a -> Edit as [ a ] bs [ a ] 

data Edits xs ys where
  ENil :: Edits [] [] 
  ECons :: Edit as bs cs ds -> Edits (as :++: xs) (cs :++: ys) -> Edits (bs :++: xs) (ds :++: ys) 
\end{minted}
	
	The definition of \texttt{Edits} is rejected because the type parameters
	\texttt{xs} and \texttt{ys} are ambiguous. The problem is that 
	in general it is not possible to invert type families, therefore
	the type checker refuses to find suitable parameters \texttt{xs} and 
	\texttt{ys}, to solve unification problems such as \texttt{zs = as :++: xs},
	for some given \texttt{zs}. This issue could be resolved including
	two singleton lists \texttt{SList xs} and \texttt{SList ys} in \texttt{ECons},
	which would however slightly obfuscate the code.
	Note that this is not an issue in Agda data types because parameters
	must all be declared either as implicit or explicit arguments and 
	hence are always available, which is the essence of the fix proposed
	using singleton lists.	
	
	To sidestep all these limitations the edit script data type have been defined 
	similarly to that of Lempsink et al. in \cite{Lemp09}, 
	collapsing edits and edit script into
	a single data type and introducing specific constructors for
	each kind of edit. Note that this definition completely preserves type safety,
	but it is only more repetitive.

\todo{Margin fix}
\begin{minted}{haskell}
data ES xs ys where
  Ins :: Diff a => F xs a -> ES ys (xs :++: zs) -> ES ys (a ': zs)
  Del :: Diff a => F xs a -> ES (xs :++: ys) zs -> ES (a ': ys) zs
  Upd :: Diff a => F xs a -> F ys a -> ES (xs :++: zs) (ys :++: ws) -> ES (a ': zs) (a ': ws)
  End :: ES [] []
\end{minted}

	\subsection{Memoization}
	The \texttt{diff} algorithm described in \ref{subsec:AlgoDiff} is inefficient 
	because the same subcomputations are recomputed multiple times.
	An equivalent, but more efficient, version can be achieved using 
	memoization, i.e. storing the result of subcomputations in a lookup-table,
	encoded by the following data type:
	
\begin{minted}{haskell}	
data EST xs ys where
  NN :: ES [] [] -> EST [] []
  NC :: Diff b => F xs b -> ES [] (b : ys) 
     -> EST [] (xs :++: ys) 
     -> EST [] (b : ys)
  CN :: Diff a => F xs a -> ES (a : ys) [] 
     -> EST (xs :++: ys) []
     -> EST (a : ys) []
  CC :: (Diff a, Diff b) => F xs a -> F ys b 
     -> ES (a : zs) (b ': ws) 
     -> EST (a : zs) (ys :++: ws)
     -> EST (xs :++: zs) (b : ws)
     -> EST (xs :++: zs) (ys :++: ws)
     -> EST (a : zs) (b : ws)
\end{minted}
	
	A table of type \texttt{EST xs ys} contains an edit script
	of minimal cost of type \texttt{ES xs ys}, and the subtables
	corresponding to its tail, obtained by placing either an insert,
	a delete, or an update edit.
	The table is partitioned in four groups depending on the fact
	that the source and target list is empty or not.
	Specifically \texttt{NN} contains the only edit script in which both
	of them are empty, in \texttt{CN} and \texttt{NC} the target and source
	lists are respectively empty and hence contain only one subtable,
	lastly in \texttt{CC} the lists are both non-empty.
	The edit script contained in a table can be easily retrieved:
	
\begin{minted}{haskell}
getDiff :: EST xs ys -> ES xs ys
getDiff (NN e) = e
getDiff (NC _ e _) = e
getDiff (CN _ e _) = e
getDiff (CC _ _ e _ _ _) = e
\end{minted}

	The function \texttt{diffT} builds a memoization table recursively:

\begin{minted}{haskell}
diffT :: DList xs -> DList ys -> EST xs ys
diffT DNil DNil = NN End
diffT (DCons (Node a as) xs) DNil = CN a (Del a (getDiff d)) d 
  where d = diffT (dappend as xs) DNil
diffT DNil (DCons (Node b bs) ys) = NC b (Ins b (getDiff i)) i
  where i = diffT DNil (dappend bs ys)
diffT (DCons (Node a as) xs) (DCons (Node b bs) ys) = CC a b (best a b i d u) i d u
  where u = diffT (dappend as xs) (dappend bs ys)
          i = extendI a xs u
          d = extendD b ys u
\end{minted}
 
	The only interesting case is the last one, in which 
	both the input lists are non-empty.
	Firstly note there is only \emph{one} recursive call to \texttt{diffT},
	which is well-founded because both the input lists are consumed 
	removing the nodes \texttt{a} and \texttt{b}.
	From the table so obtained, the alternative tables in which 
	\texttt{a} is inserted or \texttt{b} is deleted are obtained using the functions
	\texttt{extendI} and \texttt{extendD}.
	Among these three options, the script with minimal cost is chosen
	by the function \texttt{best}.
	
\begin{minted}{haskell}
best :: (Diff a, Diff b)
     => f as a -> f bs b
     -> EST (a : xs) (bs :++: ys)
     -> EST (as :++: xs) (b : ys)
     -> EST (as :++: xs) (bs :++: ys)
     -> ES (a : xs) (b : ys)
best f g i d c = 
  case decEq f g of
    Just Refl -> Upd f g (getDiff c) & a & b
    Nothing -> a & b
  where a = Del f (getDiff d)
          b = Ins g (getDiff i)
\end{minted}
	
	Both nodes can be consumed by an update only if they have the 
	same type, which is tested by the \texttt{decEq} function.
 	The other alternatives, which are always possible, consists of deleting
 	the first node or inserting the second. Note that the source and target
 	lists of the three tables are the same of their edit script, hence the scripts
 	produced are all well-typed.

	The binary operator \texttt{\&} selects the edit script with minimal cost:

\begin{minted}{haskell}
(&) :: ES xs ys -> ES xs ys -> ES xs ys
x & y = if cost x <= cost y then x else y
\end{minted}

	The function \texttt{cost} computes the score of an edit script,
	according to the cost model described in \ref{subsec:AlgoDiff}.

\begin{minted}{haskell}
cost :: ES xs ys -> Double	
cost End = 0
cost (Ins x xs) = 1 + cost xs
cost (Del x xs) = 1 + cost xs
cost (Upd f g xs) = distance f g + cost xs
\end{minted}

	Of course the \texttt{cost} function inefficiently recomputes the cost of an 
	edit script multiple times.
	It is entirely straightforward to adjust the edit script data type or the 
	memoization table to store also the score of each edit script.
	I have decided to omit this optimization from the presentation in order
	to keep it clear	and focused on the type related issues, which are 
	more interesting and challenging.
		
	The function \texttt{extendI} use an auxiliary intermediate 
	data type \texttt{DES} used to existentially quantify the portion of the table
	that needs to be extended.
	
\begin{minted}{haskell}
data DES a xs ys where
  DES :: F zs a -> ES (a : xs) ys -> EST (zs :++: xs) ys -> DES a xs ys
\end{minted}

	If the source list is non-empty, then it is possible to produce such a
	data type.

\begin{minted}{haskell}
extractD :: EST (a : xs) ys -> DES a xs ys
extractD (CN g e i) = DES g e i
extractD (CC f g e _ i _) = DES f e i
\end{minted}

	Note that the type \texttt{a : xs} in the target list restrict the possible
	values of \texttt{EST} only to those listed.

	Finally \texttt{extendI} is defined as follows:
	
\begin{minted}{haskell}	
extendI :: Diff a => F xs a -> DList ys -> EST zs (xs :++: ys) -> EST zs (a ': ys)
extendI f _ i@(NN e) = NC f (Ins f e) i
extendI f _ i@(NC _ e _) = NC f (Ins f e) i
extendI f _ i@(CN _ _ _) =
  case extractD i of
    DES g e c -> CC g f (best g f i d c) i d c
      where d = extendI f ⊥ c
extendI f _ i@(CC _ _ e _ _ _) =
  case extractD i of
    DES g e c -> CC g f (best g f i d c) i d c
      where d = extendD f ⊥ c
\end{minted}

	First of all the second argument of type \texttt{DList ys} is never inspected
	and it is introduced only to avoid the ambiguity problem discussed 
	previously.
	Extending the target list does not affect the source list, hence
	the tables \texttt{NC} and \texttt{CC} keep the same constructor.
	On the other hand when the target list is empty, in the \texttt{NN} and
	\texttt{CN} case, the constructor is substituted respectively by
	\texttt{NC} and \texttt{CC}.
	In the last two cases the function \texttt{extractD} is used to extract
	the appropriate node \texttt{g}, edit script \texttt{e} and table
	\texttt{c}, needed to compute the recursive extension \texttt{d}
	and lastly select the table with minimal cost.
		
	The function \texttt{extendD} is analogous and thus omitted.

	\subsection{Algorithm}
	\label{subsec:HaskellAlgo}
	Using all the constructs defined previously, the conventional
	interface of GNU diff can be easily made available to the
	user:

\begin{minted}{haskell}
gdiff :: (Diff a, Diff b) => a -> b -> ES '[ a ] '[ b ]
gdiff x y = getDiff (diffT dx dy)
  where dx = DCons (toDTree x) DNil
         dy = DCons (toDTree y) DNil
\end{minted}
	
	The inverse function \texttt{patch}, which computes the target
	object from the edit script, is also part of the interface
	provided to the user.

\begin{minted}{haskell}
patch :: ES xs ys -> DList ys
patch (Ins x e) = insert x (target e)
patch (Del x e) = target e
patch (Upd x y e) = insert y (target e)
patch End = DNil
\end{minted}

	The function \texttt{insert} pops the arguments of the 
	constructor from the given \texttt{DList} and builds
	a well-typed \texttt{DTree} which is then pushed on the list.

\begin{minted}{haskell}
insert :: Diff a => F xs a -> DList (xs :++: ys) -> DList (a ': ys)
insert x ds = DCons (Node x ds1) ds2
  where (ds1, ds2) = dsplit (reifyArgs x) ds
\end{minted}

	The function \texttt{dsplit} is entirely similar to the function
	\texttt{dsplit} described in \ref{par:UtilityFun}, the first 
	argument is a singleton type needed due to the strict
	phase separation enforced in Haskell.
	The function \texttt{reifyArgs} retrieves the singleton
	type relative to its arguments.

\begin{minted}{haskell}
reifyArgs :: Diff a => F xs a -> SList xs
reifyArgs = toSList . argsTy
\end{minted}

	\subsection{Discussion and Related Work}
	The edit script data type and the memoization technique 
	employed in the \texttt{diff} algorithm presented in this section
	are largely inspired by the work on type-safe diff by 
	Lempsink \cite{Lemp09}.
	As remarked in section \ref{subsec:RelatedWork}, the update
	edit used represents a generalization of the original copy edit, 
	and has been preferred because it improves the alignment of nodes, 
	simplifying the merging phase in the \texttt{diff3} algorithm.
	The \texttt{diff} algorithm requires to write some boilerplate code, about
	the same amount of that by Lempsink.
	In particular for any type involved an instance of \texttt{Diff} have
	to be provided, which requires to define a data type that encodes its
	constructors.
	The code for most of the methods of \texttt{Diff} is
	entirely straightforward and can be automatically generated using
	a preprocessor or a meta-programming library such as Template Haskell
	\cite{TemplateHaskell}. Only the implementation of \texttt{distance}
	is in general domain specific and it must adhere to certain axioms and thus 
	should	be provided manually by the user.

	\paragraph{Kind system}
	The enrichment of the \emph{kind} system proposed in
	\cite{Yorgey12} and available from GHC 7.6
	makes the data type definitions ``well-kinded''
	and reduce the additional machinery needed to deal with them.
	Specifically using the DataKinds extension lists are 
	automatically promoted and allows to index the \texttt{ES}
	and \texttt{DList} data types with lists of types, whose kind is 
	\texttt{[ * ]}.
	Direct pattern match is possible and does not required 
	additional class constrains, such as \texttt{IsList}.
	Furthermore the kind system has been enhanced so that
	the correct kind is automatically inferred, reducing the number
	of kind annotations needed. Most of the time kinds 
	annotations are superfluous and some have been
	added exclusively for documentation purposes.
	The memoization related functions have been greatly 
	simplified using auxiliary intermediate GADTs to
	existentially quantify variables, as opposed to the continuation
	style employed by  Lempsink, in which functions take
	an higher rank function as an additional parameter.
	The two approaches are roughly equally expressive, however
	direct style code is much more readable and concise.
	As a result the implementation proposed in this thesis 
	requires less boilerplate code and it is closer to the
	Agda version, showing how dependently typed programming
	is becoming more and more natural in Haskell.

	\paragraph{Change Detection}
	The technique employed by Lempsink et al. in the 
	change detection phase for structured data is a variation of
	that proposed by Lozano and Valiente to solve the
	Maximum Common Embedded Subtree problem \cite{Lozano}.
	The input trees are flattened to a list of nodes according to the 
	depth-first perorder traversal and then the longest common
	subsequence of them is computed, similarly to what happens
	in GNU diff. The algorithm proposed in this section follows
	a similar technique, with small differences in the list data type 
	processed in a stack like fashion.

	\paragraph{HList vs DList}	
	In \cite{Lemp09} the input list is an heterogeneous list, whose 
	raw types are progressively deconstructed exposing the 
	reified constructor and pushing its	children on the stack. In this version instead the \texttt{DTree} data type already contains
	the nodes of the root and its children.
	Due to the lazy semantics of Haskell 
	the two transformations should have approximately the same performance,		
	however there are several advantages in the encoding proposed in this
	thesis.
	
	First of all in \cite{Lemp09} constructors are compared implicitly,
	by trying to deconstruct a value of a raw type against the constructor
	at hand. This is achieved using the partial method \texttt{fields} of type,
	adapted to our definitions, \texttt{f as a -> a -> Maybe (HList as)},
	which is included in the type class \texttt{Diff} and it is used to
	implement the auxiliary function \texttt{matchConstructor}, in the
	\texttt{diff} algorithm.
	In this version instead such method is requires as a primitive,
	specifically in the operator \texttt{=?=} in the type class \texttt{Family} 
	\ref{subsec:Universe}, which explicitly tests for equality 
	between nodes.
	It is much more concise to test equality at once using the latter,
	rather than indirectly trying to match the given constructor,
	with all the possible constructors of a given type.
	In addition that method requires the additional type class \texttt{Type} that 
	provides a method \texttt{constructors}, which 
	returns a list of all the constructors of a given type.
	Secondly comparing the nodes directly does not require to 
	explicitly distinguish between concrete and abstract data types, as 
	it happens in \cite{Lemp09}.
	In summary the encoding provided by \texttt{DList} yields a
	minimal and neat design that requires less boilerplate code,
	which is often source of nasty bugs.
	
	\paragraph{Patch}
	The \texttt{patch} function described in \cite{Lemp09} provides the 
	same interface of GNU patch and applies an edit script 
	to the source object, encoded as an heterogeneous list.
	The semantics of delete and consequently copy relies
	on the partial function \texttt{fields}, which deconstructs the input
	value expecting a certain specific constructor and fails ungracefully,
	if this is not the case.
	As a matter of fact the edit script data type already contains enough 
	information to reconstruct \emph{both} the source and target object.
	Section \ref{subsec:HaskellAlgo} and \ref{subsec:par:SourceTargetObj} show
	two total function that retrieve both from the edit script alone.
	The formal model heavily relies on this property and the advantages with respect to safety for a 
	practical implementation	are evident.
	Note that 	the same could be achieved in \cite{Lemp09} using
	exclusively the \texttt{insert} and \texttt{apply} function.

	\paragraph{Modularity}
	The universe representation proposed by Lempsink et al.\ in \cite{Lemp09}
	handles families of mutually recursive data types.
	Specifically it requires to collect in a unique data type all the constructors of
	each type present in the family of mutually recursive data types at hand.
	This choice of encoding does not support polymorphic data types, 
	such as list, which must be 	restricted to be monomorphic. 
	As a result the same polymorphic data type, instantiated differently, need 
	separate labels in the representative family, resulting in code duplication.
	For example the type \texttt{[[Int]]} would need the following
	universe:

\begin{minted}{haskell}
data Table xs a where
  Int' :: Int -> Table '[] Int	

  INil :: Table '[] [Int]
  ICons :: Table '[Int, [Int]] [Int]

  LNil :: Table '[] [[Int]]
  LCons :: Table '[[Int], [[Int]]] [[Int]]	
\end{minted}
	The universe representation is not polymorphic, hence
	two different witnesses are needed for \texttt{[]} and \texttt{(:)} : 
	\texttt{INil} and \texttt{ICons} for \texttt{[Int]}, 
	\texttt{LNil} and \texttt{LConst} for \texttt{[[Int]]}.
	
	The encoding proposed in this thesis does not need 
	to handle all the types involved at once, but each instance
	and representation is given separately per type.
	This approach support	s polymorphic data types and it 
	is modular, allowing code reuse.
	For example the same example would need only one
	instance and one representative family for lists:
	
\begin{minted}{haskell}
data ListF xs a where
  Nil :: ListF '[] [a]
  Cons :: ListF '[a , [a]] [a]
	
instance Diff a => Diff [a] where	
  type FamilyOf [a] = ListF
\end{minted}
	
	Given an instance for \texttt{Diff Int} an appropriate
	instance can be automatically generated for \texttt{[[Int]]},
	reusing the polymorphic list instance twice.
	From \texttt{Diff Int}, the instance \texttt{Diff [Int]} can be derived,
	which is then used to derive \texttt{Diff [[Int]]}.
	
\begin{minted}{haskell}
data IntF xs a where
  Int' :: Int -> IntF '[] Int

instance Diff Int where
  type FamilyOf Int = IntF
\end{minted}

	See chapter/appendix \ref{ExampleChapter} for a complete example.
	
	\section{Diff$_3$}
	This section shows the Haskell implementation of the
	\texttt{diff3} algorithm discussed in \ref{subsec:diff3}.
	The differences are minimal and the only remarkable distinction
	is that the implementation is less safe than the one
	proposed in the formal model, because of the limitations
	of data type promotion.
	
%		The differences are
%	Sections \ref{subsec:ES3} contains the basic data types definitions. 

	\subsection{Edit Script}
	\label{subsec:ES3}
	The \texttt{ES3 xs} data type represents a merged edit script,
	whose source object has type list \texttt{xs} and it
	is almost identical to the \texttt{ES} data type.
	
\begin{minted}{haskell}
data ES3 xs where
  Ins3 :: Diff a => F xs a -> ES3 ys -> ES3 ys
  Del3 :: Diff a => F xs a -> ES3 (xs :++: ys) -> ES3 (a ': ys) 
  Upd3 :: Diff a => F xs a -> F ys a -> ES3 (xs :++: zs) -> ES3 (a ': zs) 
  Cnf3 :: VConflict -> ES3 xs -> ES3 ys
  End3 :: ES3 '[] 
\end{minted}

	The edit script is type safe only with respect
	to the source list for the reasons listed in \ref{subsec:Diff3}.	
	It is convenient to retain this bit of type safety because it 
	simplifies the type checking phase, which then has to detect type 
	errors with respect to the output list only.
	The \texttt{VConflict} data type denotes the presence
	of a conflict and corresponds to the \texttt{Conflict}
	data type discussed in \ref{subsec:Merge}.
\begin{minted}{haskell}
data VConflict where
  InsIns :: (Diff a, Diff b) => F xs a -> F ys b -> VConflict
  UpdDel :: Diff a => F xs a -> F ys a -> VConflict
  DelUpd :: Diff a => F xs a -> F ys a -> VConflict
  UpdUpd :: Diff a => F xs a -> F ys a -> F zs a -> VConflict
\end{minted}

	However since conflicts already produce an ill-typed edit script
	it has been simplified not to include
	in its type any information about the values involved.
		
	\subsection{Algorithm}
	\label{subsec:Diff3Algo}
	The function \texttt{merge3} merges the changes from 
	two aligned edit scripts and corresponds to that presented
	in \ref{subsec:diff3}.

\begin{minted}{haskell}
merge3 :: ES xs ys -> ES xs zs -> ES3 xs
merge3 (Upd o x e1) (Upd o' y e2) =
  case aligned o o' of
    (Refl, Refl) ->
      case (o =?= x, o' =?= y, x =?= y) of
        (Just (Refl, Refl), _, _) -> Upd3 o y (merge3 e1 e2) -- Id1
        (_, Just (Refl, Refl), _) -> Upd3 o x (merge3 e1 e2) -- Id2
        (_, _, Just (Refl, Refl)) -> Upd3 o x (merge3 e1 e2) -- Idem
        (_, _, _                ) -> Cnf3 (UpdUpd o x y) (merge3 e1 e2)
merge3 (Upd o x e1) (Del o' e2) =
  case aligned o o' of
    (Refl, Refl) -> 
      case o =?= x of
        Just (Refl, Refl) -> Del3 o (merge3 e1 e2) -- Id1
        Nothing           -> Cnf3 (UpdDel o x) (merge3 e1 e2)
merge3 (Del o e1) (Upd o' y e2) = 
  case aligned o o' of
    (Refl, Refl) -> 
      case o' =?= y of
        Just (Refl, Refl) -> Del3 o (merge3 e1 e2) -- Id2
        Nothing           -> Cnf3 (DelUpd o y) (merge3 e1 e2)
merge3 (Del x e1) (Del y e2) =
  case aligned x y of
    (Refl, Refl) -> Del3 x (merge3 e1 e2) -- Idem
merge3 (Ins x e1) (Ins y e2) =
  case x =?= y of
    Just (Refl, Refl) -> Ins3 x (merge3 e1 e2) -- Idem
    Nothing           -> Cnf3 (InsIns x y) (merge3 e1 e2)
merge3 (Ins x e1) e2 = Ins3 x (merge3 e1 e2) -- Id2
merge3 e1 (Ins y e2) = Ins3 y (merge3 e1 e2) -- Id1
merge3 End End = End3
\end{minted}

	Notably Haskell does not allow to promote GADTs \cite{Yorgey12}, 
	therefore it is impossible to define a data type that ensures the
	alignment of two edit scripts, such as \texttt{e₁ ⋎ e₂}.
	Consequently the alignment condition is checked at
	run-time by the function \texttt{aligned} 
	and the merge is aborted ungracefully if this is not the case.

\begin{minted}{haskell}
aligned :: (Diff a, Diff b) => F xs a -> F ys b -> (xs :~: ys , a :~: b)
aligned a b =
  case decEq a b of
    Just Refl ->  
      case a =?= b of
        Just Refl -> (Refl, Refl)
        _ -> error "Scripts not aligned"
\end{minted} 

	For the same reason the merging conditions, described in the formal 
	model by \texttt{f ⊔ g ↧ h}, are checked directly
	comparing for equality the nodes involved. The corresponding conditions
	have been added in form of a comment to help the reader's intuition.
	The \texttt{Nop} operations have been excluded from the edit
	script data type and the effect of the extension discussed in 
	\ref{par:Extension} is achieved via pattern matching.
	In particular the \texttt{Ins}-\texttt{Ins} case is matched first and
	in the remaining cases, in which only one of the two edits is insert,
	the insert is just added to the merged script. 
	In the formal model this is equivalent to aligning \texttt{Ins α} with
	a dummy \texttt{Nop} operation, which would produce the former upon 
	merge.
	
	\subsection{Type Checking}
	\label{subsec:TyCheck}
	In order to retrieve the merged target object, the edit script 
	produced by \texttt{merge3} has to be type checked in order transform it 
	into a well-typed edit script.
	The algorithm implements the typing rules listed in \ref{subsec:Merged3}
	and reports all the type errors detected in a script.
	The following data type encodes the target type list 
	inferred for an edit script.
	
\begin{minted}{haskell}
data InferredType xs where
  INil :: InferredType '[]
  ICons :: (x :<: f) => Proxy x -> InferredType xs -> InferredType (x ': xs)
  Top :: InferredType xs
\end{minted}	
	Additionally the constructor \texttt{Top} denotes an arbitrary list of types
	and it is assigned to edit scripts that are ill-typed or that contain a conflict.
	The data type \texttt{IES xs} pairs together an edit script and its inferred 
	type.
\begin{minted}{haskell}
data IES xs where
  IES :: InferredType ys -> ES xs ys -> IES xs
\end{minted}
	 Note that the list of types \texttt{ys} must be existentially quantified,
	 because it is not possible to know in advance the resulting type, as was 
	 explained in \ref{subsec:Merged3}.
	
	\paragraph{Type errors}
	Type errors are represented by the data type \texttt{TypeError}:
\begin{minted}{haskell}
data TypeError where
  TyErr :: ExpectedType xs -> InferredType ys -> TypeError
\end{minted}
	
	The type \texttt{InferredType ys} denotes the actual type found for
	some edit script, while the data type \texttt{ExpectedType xs} is just a 
	wrapper around \texttt{TList xs}:
\begin{minted}{haskell}
newtype ExpectedType xs = ET (TList xs)
\end{minted}

	Type errors and value conflicts are all reported as conflicts while type 
	checking:
\begin{minted}{haskell}
data Conflict = VConf VConflict
               | TConf TypeError
\end{minted}
	
	\paragraph{Unification}
	The second typing rule discussed in section 
	\ref{subsec:Merged3} requires to check whether the list of types \texttt{xs} 
	expected as argument by some node of type \texttt{f xs a} is a prefix of 
	\texttt{zs}, the list of output types inferred for the edit script at hand.
	The data type \texttt{IsPrefixOf xs zs} represents such a proof:

\begin{minted}{haskell}
data IsPrefixOf xs zs where
  Prefix :: InferredType ys -> Unify (xs :++: ys) zs -> IsPrefixOf xs zs
\end{minted}

	More precisely \texttt{xs} is a prefix of \texttt{zs}, if there is a suffix 
	\texttt{ys}, possibly empty, such that \texttt{xs :++: ys} equals to 
	\texttt{zs}.
	The type \texttt{Unify as bs}  denotes that the two list of types 
	\texttt{as} and \texttt{bs} can be unified.

\begin{minted}{haskell}
data Unify as bs where
  Same :: Unify as as
  Failed :: Unify as bs
\end{minted}

	The second constructor \texttt{Failed} it is used to handle properly the 
	super type \texttt{Top}, which by assumption unifies with any type.
	
	With these definitions in place it is straightforward to implement
	the function \texttt{isPrefixOfTy}, which checks whether some 
	concrete list of types is a prefix of the given inferred list:
	
\begin{minted}{haskell}
isPrefixOfTy :: TList as -> InferredType bs -> Maybe (IsPrefixOf as bs)
isPrefixOfTy TNil s = Just (Prefix s Same)
isPrefixOfTy s Top = Just (Prefix Top Failed)
isPrefixOfTy (TCons _ _) INil = Nothing
isPrefixOfTy (TCons x s1) (ICons y s2) =
  case (tyEq x y, isPrefixOfTy s1 s2) of
    (Just Refl, Just (Prefix s Same)) -> Just (Prefix s Same)
    (Just Refl, Just (Prefix s Failed)) -> Just (Prefix s Failed)
    _ -> Nothing
\end{minted}
	
	The function is defined by induction on the two lists.
	In the first base case it follows immediately that the empty list is
	the prefix of any list. In the second case, any list unifies
	with \texttt{Top} by assumption, hence instead of failing
	the unifier \texttt{Failed} is used. Note that without this constructor
	the type checker would prevent us to produce a value of type
	\texttt{IsPrefixOf}.
	On the other hand in the third base case a nonempty list cannot possibly
	unify with the empty list, hence \texttt{Nothing} is returned.
	In the last recursive case, in which both the lists are nonempty, the first 
	types are compared and \texttt{isPrefixOfTy} is called recursively
	on their tails. If a list is a prefix of another, adding the same type to both
	the two lists preserves the property. For this reason if the first tails is a 
	prefix of the second and the two types are equal the same suffix
	\texttt{s} is retained. Note that it is necessary to explicitly pattern match
	on the unifier to convince the type checker of this property.
	If these conditions are not met, a negative answer is reported in form of 
	\texttt{Nothing}.	
		
	\paragraph{Algorithm}
	Since it is preferable to report at once all the conflicts found in an edit script
	the type checker reports a list of conflicts and the converted typed edit
	script, whose type have been inferred.
	
\begin{minted}{haskell}
tyCheck :: Family f => ES3 xs -> ([Conflict], IES xs)
tyCheck End3 = ([], IES INil End)
tyCheck (Cnf3 c e) =
  case tyCheck e of
    (tyErr, IES ty e') -> (VConf c : tyErr, IES Top ⊥)
tyCheck (Del3 x e) =
  case tyCheck e of
    (tyErr, IES ty e') -> (tyErr, IES ty (Del x e'))
tyCheck (Ins3 x e) =
  case tyCheck e of
    (tyErr, IES ty e') ->
      let xs = argsTy x in
      case xs `isPrefixOfTy` ty of
        Just (Prefix xsys Same) -> (tyErr, IES (ICons Proxy xsys) (Ins x e'))
        Just (Prefix xsys Failed) -> (tyErr, IES (ICons Proxy xsys) (Ins x ⊥))
        Nothing -> (TConf (TyErr (ET xs) ty) : tyErr, IES (ICons Proxy Top) (Ins x ⊥))
tyCheck (Upd3 x y e) =
  case tyCheck e of
    (tyErr, IES ty e') ->
      let ys = argsTy y in
      case ys `isPrefixOfTy` ty of
        Just (Prefix yszs Same) -> (tyErr, IES (ICons Proxy yszs) (Upd x y e'))
        Just (Prefix yszs Failed) -> (tyErr, IES (ICons Proxy yszs) (Upd x y ⊥))
        Nothing -> (TConf (TyErr (ET ys) ty) : tyErr, IES (ICons Proxy Top) (Upd x y ⊥))
\end{minted}

	In the base case the empty edit script is converted to the corresponding
	typed script, whose output type list is empty.
	The value related conflicts are simply added to the list of conflicts
	and since there is no edit script counterpart the converted edit script
	is filled with \texttt{⊥}, i.e. \texttt{undefined}, and assigned type 
	\texttt{Top}. In the \texttt{Del3} case no check is required, because
	only the input list is affected by this edit and the \texttt{ES3} data type is 
	already well-typed with respect to it.
	On the other hand converting the \texttt{Ins3 x} and \texttt{Upd3 x y} edits
	requires to verify that the output type of the rest of the edit script 
	contain the types demanded respectively by the constructors \texttt{x} and 
	\texttt{y}. These types are extracted using \texttt{argsTy} and the
	auxiliary function \texttt{isPrefixOf} is used to match them
	against \texttt{ty}, the type inferred for the rest of the edit script, obtained
	by a recursive call to \texttt{tyCheck}.
	Once more pattern matching on the unifier object is required to actually
	convince the type checker. When the unification is vacuous,
	denoted by \texttt{Failed}, the converted edit scrip is substituted with
	\texttt{⊥}. Nevertheless, even in these circumstances, part of the correct 
	type 	is inferred and reported, so that further type errors, independent
	from the previous ones, can still be detected.	
	
	Note that using \texttt{⊥} is safe because the converted edit script is 
	never inspected in \texttt{tyCheck} and thus never evaluated according to
	Haskell's lazy semantics.
	The invariant maintained by \texttt{tyCheck} is that the inferred edit
	script is fully defined only if no conflicts have been detected. Furthermore
	in that case the inferred type does not contain \texttt{Top}.
	Therefore a safer interface is provided by means of \texttt{typeCheck},
	which returns either a non empty list of conflicts or a well-type edit script.
	
\begin{minted}{haskell}
typeCheck :: Family f => ES3 xs -> Either [Conflict] (WES xs)
typeCheck e =
  case tyCheck e of
    ([]  , IES ty e') -> Right $ WES (toTList ty) e'
    (errs, _        ) -> Left errs
\end{minted}
%$

	The data type \texttt{WES} stands for well-typed edit script, and it differs
	from \texttt{IES} because the output type \texttt{ys} is stored as a
	\texttt{TList}, instead of \texttt{InferredType} and therefore
	does not contain any \texttt{Top} type.
	Note that, even if a script is well-typed, its output type list still needs 
	to be existentially quantified.
	
\begin{minted}{haskell}
data ES xs where
  WES :: TList ys -> ES xs ys -> WES xs
\end{minted}

	Finally for user's convenience the canonical \texttt{diff3} interface is
	provided, which expects three arguments, the second 
	being the original version and the first and the third being the new ones.
	Note that those must have the same type, hence in this specific
	case the expected output type of the edit script is known.
	In this function the converted edit script is therefore also type-checked 
	against it and an appropriate conflict is reported otherwise.
	
\begin{minted}{haskell}
diff3 :: (Diff a, Diff b) => b -> a -> b -> Either [Conflict] (ES '[ a ] '[ b ])
\end{minted}

	\section{Version Control System}
	This sections presents a prototype of a structure-aware version control 
	system that put the results presented previously into practice.
	The prototype is not meant to be of production quality, but rather
	a proof of concept that shows the applicability of the ideas discussed 
	in this thesis.
	
	\subsection{Design}	
	The design of the prototype is inspired by Git \cite{GIT}.
	The repository is modeled as directed acyclic graph (DAG), in 
	which every node may have at most two parents. The only node without
	parents is the root, which contains the initial state; nodes
	with only one parent denote single commits, while nodes with
	two parents are reserved for merges between two 	branches.
	Each node in the graph is identified by the hash of the path that
	goes from the root to it.
	Since the most common operations, e.g. commit, branching and merging,
	are performed on the tip of a branch, paths are stored backwards,
	so that these operations can be implemented efficiently.
	
\begin{minted}{haskell}
data Path a = Root a
              | Node  (Path a) Depth (Delta a)
              | Merge (Path a) (Path a) Depth (Delta a)
\end{minted}
			
	To keep the prototype simple, objects under revision are restricted to
	keep the same type \texttt{a}. Except the root, all nodes do
	not store a plain value, but only a \texttt{Delta}, i.e.\ an edit script 
	that contains the 	differences from the previous version.
\begin{minted}{haskell}
type Delta a = ES '[ a ] '[ a ]
\end{minted}
	
	In addition each non-root node stores its depth, i.e.\ the length of the 
	path that goes from the root to it.
	The depth of a path can be easily retrieved:
\begin{minted}{haskell}
depth :: Path a -> Depth
depth (Root _) = 0
depth (Node _ d _) = d
depth (Merge _ _ d _) = d
\end{minted}

	Paths have strictly increasing depths, therefore, in order to maintain this 
	invariant, the \texttt{Path} data type is kept abstract 
	and smart constructors are provided instead:

\begin{minted}{haskell}
root :: a ->  Path a
root = Root

node ::  Path a -> Delta a ->  Path a
node p = Node p (depth p + 1)

merge :: Path a -> Path a -> Delta a ->  Path a
merge p1 p2 e = Merge p1 p2 (max (depth p1) (depth p2) + 1) e
\end{minted}
	
	Furthermore the current value of an object can reconstructed from the path:

\begin{minted}{haskell}
value :: Diff a => Path a -> a
value (Root x) = x 
value (Node _ _ e) = patch e
value (Merge _ _ _ e) = patch e
\end{minted}

	Where \texttt{patch} is a type-restricted version of \texttt{target}
	which additionally converts a \texttt{DTree} to a raw value. Its
	implementation is straightforward and thus omitted.
\begin{minted}{haskell}
patch :: Diff b => ES '[ a ] '[ b ] -> b
\end{minted}
	
	Since the target object can be retrieved directly from an edit script 
	without the need of the source object, computing the current
	value of a path does not require patching all the previous deltas 
	from the root.
	
	\subsection{Lowest Common Ancestor}
	The lowest common ancestor, henceforth LCA, of two nodes is the lowest
	node, i.e.\ deepest from the root, that is an ancestor of both of them.	
	In a tree the LCA is unique, however in a DAG there could be more.
	In a connected DAG, in which every node has at most two parents, there are at most
	two lowest common ancestors for every node.
	This property is useful when merging two branches and it is explained 
	in more detail in \ref{subsec:MergeLCA}.
	The LCA is represented accordingly by the following data type:

\begin{minted}{haskell}
data Lca a = One (Path a)
             | Two (Path a) (Path a)
\end{minted}

	Furthermore to take advantage of the faster hash-based comparison
	for paths, the wrapper \texttt{HPath} is used:
	
\begin{minted}{haskell}
newtype HPath a = HPath {hpath :: Path a}
\end{minted}
	The appropriate \texttt{Eq} and \texttt{Ord} instances are assumed for it.
	
	Two auxiliary functions are used to compute the LCA of two paths. Firstly the function \texttt{levels} pairs all the subpaths of the given path
	by their depth in descending order.


\begin{minted}{haskell}	
levels :: Hashable a => Path a -> [(Depth, Set (HPath a))]
levels r@(Root x)= [(0, singleton (HPath r))]
levels n@(Node p d _) = (d, singleton (HPath n)) : levels p
levels m@(Merge p1 p2 d _) = (d, singleton (HPath m)) : combine (levels p1) (levels p2)
\end{minted}
	
	Secondly the function \texttt{combine} merges two such lists, combining the
	paths at the same depth. Note that due to the invariants discussed
	previously, the list returned contains an element for each depth level from
	zero to the depth of the input path.
	
\begin{minted}{haskell}
combine :: Hashable a => [(Depth, Set (HPath a))] -> [(Depth, Set (HPath a))] 
          -> [(Depth, Set (HPath a))]
combine [] ds2 = ds2
combine ds1 [] = ds1
combine a@((d1,xs) : ds1) b@((d2,ys) : ds2) =
  case compare d1 d2 of
    LT -> (d2, ys) : combine a ds2
    EQ -> (d1, xs `union` ys) : combine ds1 ds2
    GT -> (d1, xs) : combine ds1 b
\end{minted}

	Finally the function \texttt{lca} computes the lowest common ancestor
	of two paths.

\begin{minted}{haskell}
lca :: Hashable a => Path a ->  Path a -> Lca a
lca p1 p2 =
  case find (not . null) (zipWith common ls1 ls2) of
    Just s ->
      case toList s of
        [ r ] -> One (hpath r)
        [r1  r2] -> Two (hpath r1) (hpath r2	)
  where d = min (depth p1) (depth p2)
        ls1 = dropWhile ((> d) . fst) (levels p1)
        ls2 = dropWhile ((> d) . fst) (levels p2)
        common (_, x) (_, y) = intersection x y
\end{minted}

	The lists \texttt{ls1} and \texttt{ls2} contain the subpaths of each
	of the two paths, starting with the same common depth \texttt{d}.
	Since the level \texttt{d} is the minimum depth of the two paths, the
	lowest common ancestor cannot be at any depth greater than \texttt{d},
	hence dropping elements greater than \texttt{d} is safe. Furthermore
	since any path at a certain depth contains subpaths at every level
	lower than it, it follows that \texttt{ls1} and \texttt{ls2} are aligned
	with respect to their depth.
	Exploiting this property the subpaths at each level are combined by
	intersection, finding thus the common ones.
	Since these are also in descending order, 
	the first non empty set contains the deepest, i.e. the lowest.
	The set contains either one or two subpaths, which are then extracted
	and wrapped in the right constructor.
	Haskell semantics ensure that the lists of subpath and the list
	of common paths are produced and consumed lazily, therefore
	avoiding to unnecessarily process the paths at lower depths.
	
	\subsection{Merge}
	\label{subsec:MergeLCA}
	The \emph{three-way merge} algorithm merges two branches using the 
	\texttt{diff3} algorithm, in which the two new versions are the 
	latest in the branches, while their LCA's version is used as 
	base. The LCA represents the best choice because
	it is a common revision from which both the two branches diverged and
	furthermore it is the lowest, therefore the closest to both of them.
	However in some cases such as the \emph{criss-cross merge}, 
	there could be two lowest common ancestors and neither of them
	is better than the other.
	
	\paragraph{Criss-cross merge}
	The criss-cross merge occurs when there are two separate branches
	in which each branch progressively includes changes from the other,
	as shown in the figure \ref{CrissCrossImg}
	Depending on the role of the branches and the intended work-flow,
	this pattern can arise quite often.
	
	For example imagine a repository in which there are two branches,
	the main branch \texttt{master} and a development branch \texttt{dev}.
	The \texttt{dev} branch, after adding some feature in commit \texttt{2},
	is synchronized with master, pulling the changes made in \texttt{1}.
	After solving any possible conflict, the merge is committed in \texttt{4}.
	Similarly the \texttt{master} branch is merged with \texttt{dev}, 
	adding the new feature from \texttt{2} and producing a new commit 
	\texttt{3}.
	In both these merges the lowest common ancestor is the root \texttt{0},
	which is used as base in the \texttt{diff3} algorithm.
	The pattern repeats itself and now the nodes \texttt{3} and \texttt{4}
	must be merged: what node should be used as base?
	Crucially the nodes \texttt{1} and \texttt{2} are both LCA, because they are 
	ancestors of both of them and they have the same depth, however
	none of them is better than the other.
	Furthermore choosing arbitrarily one of them would raise bogus conflicts,
	because the changes made in the other would not be taken into account.
	Choosing an older, but unique ancestor is not satisfactory either.
	In this case for example using node \texttt{0} as the candidate base would
	raise the same conflicts encountered when merging \texttt{1} and \texttt{2},
	which were already solved.
	
\begin{figure}[h]
\centering
\includegraphics[scale=0.40]{../images/CrissCross}
\caption{Example of criss-cross merge.}
\label{CrissCrossImg}
\end{figure}
	
	\subsection{Recursive three-way merge}
	The \emph{recursive three-way merge} algorithm is an extension
	of the simple three-way merge algorithm, that applies in these
	circumstances.
	When two LCA are found, it builds a \emph{virtual} lowest common 
	ancestor applying the three-way merge algorithm recursively on them.
	The virtual ancestor is then used as a base in the \texttt{diff3} algorithm.
	Since the number of nodes in every path are finite the algorithm 
	eventually terminates.

	\paragraph{Example}
	In the previous example, the nodes \texttt{3} and \texttt{4} have
	two LCA, nodes \texttt{1} and \texttt{2}, therefore the three-way merge 
	is recursively applied to them. Their LCA, node \texttt{0}, is used as base
	to build a virtual ancestor \texttt{1-2}, which is finally used as base to 
	merge the nodes \texttt{3} and \texttt{4}.
	
	The recursive three-way merge can be easily implemented as follows:

\begin{minted}{haskell}
recursive3WayMerge :: (Hashable a, Diff a) => Path a -> Path a -> Either [Conflict] (Path a)
recursive3WayMerge p q = 
  case lca p q of
    One a -> mergeWithAncestor p a q 
    Two a b ->  
      case recursive3WayMerge a b of
        Left err -> Left err 
        Right c -> mergeWithAncestor p c q 
\end{minted}

	The function \texttt{mergeWithAncestor} merges two
	nodes applying the \texttt{diff3} algorithm. The arguments
	are expected in the same order as \texttt{diff3}, hence the second 
	\texttt{Path} is used as base.

\begin{minted}{haskell}	
mergeWithAncestor :: (Hashable a, Diff a) => Path a -> Path a -> Path a -> 
                        Either [Conflict] (Path a)
mergeWithAncestor p a q = 
  case diff3 x o y of
    Left err -> Left err 
    Right e -> Right (merge p q e)
  where x = value p
         o = value a
         y = value q
\end{minted}
	
	\subsection{Discussion}
	The prototype presented in this section lacks most of the
	features commonly expected in version control systems.
	For example they usually provide (graphical) user interface, 
	record meta-data 
	such as branches names and time and date of 
	commits and so on. They also communicate over the 
	network and serialize data and meta-data for persistence.
	Part of these features mostly require a great deal of 
	software engineering work and therefore have not
	been addressed in this project,
	nevertheless the prototype have all the essential ingredients
	to perform revision control interactively, including
	semi-automatic merge of revisions using the \emph{recursive three-way
	merge} algorithm.
	
	\paragraph{File system}
	Version control systems such as Git \cite{GIT} and Mercurial 
	\cite{HG} do not track single objects, but a collection of files and 
	directories. The prototype discussed in this thesis is in principle able
	to correctly simulate the same behaviour. In fact it is possible to
	model the portion of the file system under revision as a mapping
	from paths to file contents. Providing appropriate support 
	for unordered collections such as maps, it would be 
	possible to instantiate the repository, 
	as \texttt{Path (Map FileName Content)}, which would be initialized
	with the empty mapping.
	More research is needed to properly handle arbitrary data types that 
	mix structured, tree-liked data types, with unordered collections.
	The problem does not concern the alignment phase only, but it is 
	also semantic.
	For instance it is reasonable to expect that two maps are compared,
	diffing pointwise values mapped by the same key and including
	the entries that are present in one, but not in the other.
	However this approach would not handle properly changes made
	exclusively to the keys, which could happen for example 
	by renaming a file.
	These questions can dramatically affect the behaviour of a 
	structure-aware version control	system and ought to be investigated.

	\paragraph{Semantics}
	The model presented in chapter \ref{chapter:FormalModel} 
	is suitable for reasoning about merging between branches according to
	the simple three-way merge algorithm.
	Likewise it would be useful to extend it to consider
	more complex merges, that require the \emph{recursive} three-way merge.
	This extension would require to model the repository directly and
	to formally define the notion of lowest common ancestor.
	Furthermore the properties that were only informally 
	stated in this section could be formally proved.
	
	% TODO remove when compiling the whole thesis	
	\bibliographystyle{plain}
 	\bibliography{../svc}

\end{document}
